Class {
	#name : #DruidStaticTypePredictionJIT,
	#superclass : #DruidJIT,
	#category : #'VMMaker-JIT'
}

{ #category : #'class initialization' }
DruidStaticTypePredictionJIT class >> bytecodeTable [

	<generated>
	^ {
		  { 1. 0. 0. #gen_PushReceiverVariableBytecode0.
		  #isInstVarRef }.
		  { 1. 1. 1. #gen_PushReceiverVariableBytecode1.
		  #isInstVarRef }.
		  { 1. 2. 2. #gen_PushReceiverVariableBytecode2.
		  #isInstVarRef }.
		  { 1. 3. 3. #gen_PushReceiverVariableBytecode3.
		  #isInstVarRef }.
		  { 1. 4. 4. #gen_PushReceiverVariableBytecode4.
		  #isInstVarRef }.
		  { 1. 5. 5. #gen_PushReceiverVariableBytecode5.
		  #isInstVarRef }.
		  { 1. 6. 6. #gen_PushReceiverVariableBytecode6.
		  #isInstVarRef }.
		  { 1. 7. 7. #gen_PushReceiverVariableBytecode7.
		  #isInstVarRef }.
		  { 1. 8. 8. #gen_PushReceiverVariableBytecode8.
		  #isInstVarRef }.
		  { 1. 9. 9. #gen_PushReceiverVariableBytecode9.
		  #isInstVarRef }.
		  { 1. 10. 10. #gen_PushReceiverVariableBytecode10.
		  #isInstVarRef }.
		  { 1. 11. 11. #gen_PushReceiverVariableBytecode11.
		  #isInstVarRef }.
		  { 1. 12. 12. #gen_PushReceiverVariableBytecode12.
		  #isInstVarRef }.
		  { 1. 13. 13. #gen_PushReceiverVariableBytecode13.
		  #isInstVarRef }.
		  { 1. 14. 14. #gen_PushReceiverVariableBytecode14.
		  #isInstVarRef }.
		  { 1. 15. 15. #gen_PushReceiverVariableBytecode15.
		  #isInstVarRef }.
		  { 1. 16. 16. #gen_PushLiteralVariable16CasesBytecode0.
		  #needsFrameNever:. 1 }.
		  { 1. 17. 17. #gen_PushLiteralVariable16CasesBytecode1.
		  #needsFrameNever:. 1 }.
		  { 1. 18. 18. #gen_PushLiteralVariable16CasesBytecode2.
		  #needsFrameNever:. 1 }.
		  { 1. 19. 19. #gen_PushLiteralVariable16CasesBytecode3.
		  #needsFrameNever:. 1 }.
		  { 1. 20. 20. #gen_PushLiteralVariable16CasesBytecode4.
		  #needsFrameNever:. 1 }.
		  { 1. 21. 21. #gen_PushLiteralVariable16CasesBytecode5.
		  #needsFrameNever:. 1 }.
		  { 1. 22. 22. #gen_PushLiteralVariable16CasesBytecode6.
		  #needsFrameNever:. 1 }.
		  { 1. 23. 23. #gen_PushLiteralVariable16CasesBytecode7.
		  #needsFrameNever:. 1 }.
		  { 1. 24. 24. #gen_PushLiteralVariable16CasesBytecode8.
		  #needsFrameNever:. 1 }.
		  { 1. 25. 25. #gen_PushLiteralVariable16CasesBytecode9.
		  #needsFrameNever:. 1 }.
		  { 1. 26. 26. #gen_PushLiteralVariable16CasesBytecode10.
		  #needsFrameNever:. 1 }.
		  { 1. 27. 27. #gen_PushLiteralVariable16CasesBytecode11.
		  #needsFrameNever:. 1 }.
		  { 1. 28. 28. #gen_PushLiteralVariable16CasesBytecode12.
		  #needsFrameNever:. 1 }.
		  { 1. 29. 29. #gen_PushLiteralVariable16CasesBytecode13.
		  #needsFrameNever:. 1 }.
		  { 1. 30. 30. #gen_PushLiteralVariable16CasesBytecode14.
		  #needsFrameNever:. 1 }.
		  { 1. 31. 31. #gen_PushLiteralVariable16CasesBytecode15.
		  #needsFrameNever:. 1 }.
		  { 1. 32. 32. #gen_PushLiteralConstantBytecode0.
		  #needsFrameNever:. 1 }.
		  { 1. 33. 33. #gen_PushLiteralConstantBytecode1.
		  #needsFrameNever:. 1 }.
		  { 1. 34. 34. #gen_PushLiteralConstantBytecode2.
		  #needsFrameNever:. 1 }.
		  { 1. 35. 35. #gen_PushLiteralConstantBytecode3.
		  #needsFrameNever:. 1 }.
		  { 1. 36. 36. #gen_PushLiteralConstantBytecode4.
		  #needsFrameNever:. 1 }.
		  { 1. 37. 37. #gen_PushLiteralConstantBytecode5.
		  #needsFrameNever:. 1 }.
		  { 1. 38. 38. #gen_PushLiteralConstantBytecode6.
		  #needsFrameNever:. 1 }.
		  { 1. 39. 39. #gen_PushLiteralConstantBytecode7.
		  #needsFrameNever:. 1 }.
		  { 1. 40. 40. #gen_PushLiteralConstantBytecode8.
		  #needsFrameNever:. 1 }.
		  { 1. 41. 41. #gen_PushLiteralConstantBytecode9.
		  #needsFrameNever:. 1 }.
		  { 1. 42. 42. #gen_PushLiteralConstantBytecode10.
		  #needsFrameNever:. 1 }.
		  { 1. 43. 43. #gen_PushLiteralConstantBytecode11.
		  #needsFrameNever:. 1 }.
		  { 1. 44. 44. #gen_PushLiteralConstantBytecode12.
		  #needsFrameNever:. 1 }.
		  { 1. 45. 45. #gen_PushLiteralConstantBytecode13.
		  #needsFrameNever:. 1 }.
		  { 1. 46. 46. #gen_PushLiteralConstantBytecode14.
		  #needsFrameNever:. 1 }.
		  { 1. 47. 47. #gen_PushLiteralConstantBytecode15.
		  #needsFrameNever:. 1 }.
		  { 1. 48. 48. #gen_PushLiteralConstantBytecode16.
		  #needsFrameNever:. 1 }.
		  { 1. 49. 49. #gen_PushLiteralConstantBytecode17.
		  #needsFrameNever:. 1 }.
		  { 1. 50. 50. #gen_PushLiteralConstantBytecode18.
		  #needsFrameNever:. 1 }.
		  { 1. 51. 51. #gen_PushLiteralConstantBytecode19.
		  #needsFrameNever:. 1 }.
		  { 1. 52. 52. #gen_PushLiteralConstantBytecode20.
		  #needsFrameNever:. 1 }.
		  { 1. 53. 53. #gen_PushLiteralConstantBytecode21.
		  #needsFrameNever:. 1 }.
		  { 1. 54. 54. #gen_PushLiteralConstantBytecode22.
		  #needsFrameNever:. 1 }.
		  { 1. 55. 55. #gen_PushLiteralConstantBytecode23.
		  #needsFrameNever:. 1 }.
		  { 1. 56. 56. #gen_PushLiteralConstantBytecode24.
		  #needsFrameNever:. 1 }.
		  { 1. 57. 57. #gen_PushLiteralConstantBytecode25.
		  #needsFrameNever:. 1 }.
		  { 1. 58. 58. #gen_PushLiteralConstantBytecode26.
		  #needsFrameNever:. 1 }.
		  { 1. 59. 59. #gen_PushLiteralConstantBytecode27.
		  #needsFrameNever:. 1 }.
		  { 1. 60. 60. #gen_PushLiteralConstantBytecode28.
		  #needsFrameNever:. 1 }.
		  { 1. 61. 61. #gen_PushLiteralConstantBytecode29.
		  #needsFrameNever:. 1 }.
		  { 1. 62. 62. #gen_PushLiteralConstantBytecode30.
		  #needsFrameNever:. 1 }.
		  { 1. 63. 63. #gen_PushLiteralConstantBytecode31.
		  #needsFrameNever:. 1 }.
		  { 1. 64. 64. #gen_PushTemporaryVariableBytecode0 }.
		  { 1. 65. 65. #gen_PushTemporaryVariableBytecode1 }.
		  { 1. 66. 66. #gen_PushTemporaryVariableBytecode2 }.
		  { 1. 67. 67. #gen_PushTemporaryVariableBytecode3 }.
		  { 1. 68. 68. #gen_PushTemporaryVariableBytecode4 }.
		  { 1. 69. 69. #gen_PushTemporaryVariableBytecode5 }.
		  { 1. 70. 70. #gen_PushTemporaryVariableBytecode6 }.
		  { 1. 71. 71. #gen_PushTemporaryVariableBytecode7 }.
		  { 1. 72. 72. #gen_PushTemporaryVariableBytecode8 }.
		  { 1. 73. 73. #gen_PushTemporaryVariableBytecode9 }.
		  { 1. 74. 74. #gen_PushTemporaryVariableBytecode10 }.
		  { 1. 75. 75. #gen_PushTemporaryVariableBytecode11 }.
		  { 1. 76. 76. #gen_PushReceiverBytecode }.
		  { 1. 77. 77. #gen_PushConstantTrueBytecode.
		  #needsFrameNever:. 1 }.
		  { 1. 78. 78. #gen_PushConstantFalseBytecode.
		  #needsFrameNever:. 1 }.
		  { 1. 79. 79. #gen_PushConstantNilBytecode.
		  #needsFrameNever:. 1 }.
		  { 1. 80. 80. #gen_PushConstantZeroBytecode.
		  #needsFrameNever:. 1 }.
		  { 1. 81. 81. #gen_PushConstantOneBytecode.
		  #needsFrameNever:. 1 }.
		  { 1. 82. 82. #unknownBytecode }.
		  { 1. 83. 83. #gen_DuplicateTopBytecode. #needsFrameNever:.
		  1 }.
		  { 1. 84. 84. #unknownBytecode }.
		  { 1. 85. 85. #unknownBytecode }.
		  { 1. 86. 86. #unknownBytecode }.
		  { 1. 87. 87. #unknownBytecode }.
		  { 1. 88. 88. #gen_ReturnReceiver. #return. #isMappedInBlock.
		  #needsFrameIfInBlock:. 0 }.
		  { 1. 89. 89. #gen_ReturnTrue. #return. #isMappedInBlock.
		  #needsFrameIfInBlock:. 0 }.
		  { 1. 90. 90. #gen_ReturnFalse. #return. #isMappedInBlock.
		  #needsFrameIfInBlock:. 0 }.
		  { 1. 91. 91. #gen_ReturnNil. #return. #isMappedInBlock.
		  #needsFrameIfInBlock:. 0 }.
		  { 1. 92. 92. #gen_ReturnTopFromMethod. #return. #isMappedInBlock.
		  #needsFrameIfInBlock:.  -1 }.
		  { 1. 93. 93. #gen_ReturnNilFromBlock. #return. #needsFrameNever:.
		   -1 }.
		  { 1. 94. 94. #gen_ReturnTopFromBlock. #return. #needsFrameNever:.
		   -1 }.
		  { 1. 95. 95. #gen_ExtNopBytecode. #needsFrameNever:.
		  0 }.
		  { 1. 96. 96. #gen_BytecodePrimAdd. #isMapped }.
		  { 1. 97. 97. #gen_BytecodePrimSubtract. #isMapped }.
		  { 1. 98. 98. #gen_BytecodePrimLessThanSistaV1.
		  #isMapped }.
		  { 1. 99. 99. #gen_BytecodePrimGreaterThanSistaV1.
		  #isMapped }.
		  { 1. 100. 100. #gen_BytecodePrimLessOrEqualSistaV1.
		  #isMapped }.
		  { 1. 101. 101. #gen_BytecodePrimGreaterOrEqualSistaV1.
		  #isMapped }.
		  { 1. 102. 102. #gen_BytecodePrimEqualSistaV1.
		  #isMapped }.
		  { 1. 103. 103. #gen_BytecodePrimNotEqualSistaV1.
		  #isMapped }.
		  { 1. 104. 104. #gen_BytecodePrimMultiply. #isMapped }.
		  { 1. 105. 105. #gen_BytecodePrimDivide. #isMapped }.
		  { 1. 106. 106. #gen_BytecodePrimMod. #isMapped }.
		  { 1. 107. 107. #gen_BytecodePrimMakePoint.
		  #isMapped }.
		  { 1. 108. 108. #gen_BytecodePrimBitShift. #isMapped }.
		  { 1. 109. 109. #gen_BytecodePrimDiv. #isMapped }.
		  { 1. 110. 110. #gen_BytecodePrimBitAnd. #isMapped }.
		  { 1. 111. 111. #gen_BytecodePrimBitOr. #isMapped }.
		  { 1. 112. 112. #gen_BytecodePrimAt. #isMapped }.
		  { 1. 113. 113. #gen_BytecodePrimAtPut. #isMapped }.
		  { 1. 114. 114. #gen_BytecodePrimSize. #isMapped }.
		  { 1. 115. 115. #gen_BytecodePrimNext. #isMapped }.
		  { 1. 116. 116. #gen_BytecodePrimNextPut. #isMapped }.
		  { 1. 117. 117. #gen_BytecodePrimAtEnd. #isMapped }.
		  { 1. 118. 118. #gen_BytecodePrimIdenticalSistaV1 }.
		  { 1. 119. 119. #unknownBytecode }.
		  { 1. 120. 120. #gen_BytecodePrimNotIdenticalSistaV1 }.
		  { 1. 121. 121. #gen_BytecodePrimValue. #isMapped }.
		  { 1. 122. 122. #gen_BytecodePrimValueWithArg.
		  #isMapped }.
		  { 1. 123. 123. #gen_BytecodePrimDo. #isMapped }.
		  { 1. 124. 124. #gen_BytecodePrimNew. #isMapped }.
		  { 1. 125. 125. #gen_BytecodePrimNewWithArg.
		  #isMapped }.
		  { 1. 126. 126. #gen_BytecodePrimPointX. #isMapped }.
		  { 1. 127. 127. #gen_BytecodePrimPointY. #isMapped }.
		  { 1. 128. 128. #gen_SendLiteralSelector0ArgsBytecode0.
		  #isMapped }.
		  { 1. 129. 129. #gen_SendLiteralSelector0ArgsBytecode1.
		  #isMapped }.
		  { 1. 130. 130. #gen_SendLiteralSelector0ArgsBytecode2.
		  #isMapped }.
		  { 1. 131. 131. #gen_SendLiteralSelector0ArgsBytecode3.
		  #isMapped }.
		  { 1. 132. 132. #gen_SendLiteralSelector0ArgsBytecode4.
		  #isMapped }.
		  { 1. 133. 133. #gen_SendLiteralSelector0ArgsBytecode5.
		  #isMapped }.
		  { 1. 134. 134. #gen_SendLiteralSelector0ArgsBytecode6.
		  #isMapped }.
		  { 1. 135. 135. #gen_SendLiteralSelector0ArgsBytecode7.
		  #isMapped }.
		  { 1. 136. 136. #gen_SendLiteralSelector0ArgsBytecode8.
		  #isMapped }.
		  { 1. 137. 137. #gen_SendLiteralSelector0ArgsBytecode9.
		  #isMapped }.
		  { 1. 138. 138. #gen_SendLiteralSelector0ArgsBytecode10.
		  #isMapped }.
		  { 1. 139. 139. #gen_SendLiteralSelector0ArgsBytecode11.
		  #isMapped }.
		  { 1. 140. 140. #gen_SendLiteralSelector0ArgsBytecode12.
		  #isMapped }.
		  { 1. 141. 141. #gen_SendLiteralSelector0ArgsBytecode13.
		  #isMapped }.
		  { 1. 142. 142. #gen_SendLiteralSelector0ArgsBytecode14.
		  #isMapped }.
		  { 1. 143. 143. #gen_SendLiteralSelector0ArgsBytecode15.
		  #isMapped }.
		  { 1. 144. 144. #gen_SendLiteralSelector1ArgBytecode0.
		  #isMapped }.
		  { 1. 145. 145. #gen_SendLiteralSelector1ArgBytecode1.
		  #isMapped }.
		  { 1. 146. 146. #gen_SendLiteralSelector1ArgBytecode2.
		  #isMapped }.
		  { 1. 147. 147. #gen_SendLiteralSelector1ArgBytecode3.
		  #isMapped }.
		  { 1. 148. 148. #gen_SendLiteralSelector1ArgBytecode4.
		  #isMapped }.
		  { 1. 149. 149. #gen_SendLiteralSelector1ArgBytecode5.
		  #isMapped }.
		  { 1. 150. 150. #gen_SendLiteralSelector1ArgBytecode6.
		  #isMapped }.
		  { 1. 151. 151. #gen_SendLiteralSelector1ArgBytecode7.
		  #isMapped }.
		  { 1. 152. 152. #gen_SendLiteralSelector1ArgBytecode8.
		  #isMapped }.
		  { 1. 153. 153. #gen_SendLiteralSelector1ArgBytecode9.
		  #isMapped }.
		  { 1. 154. 154. #gen_SendLiteralSelector1ArgBytecode10.
		  #isMapped }.
		  { 1. 155. 155. #gen_SendLiteralSelector1ArgBytecode11.
		  #isMapped }.
		  { 1. 156. 156. #gen_SendLiteralSelector1ArgBytecode12.
		  #isMapped }.
		  { 1. 157. 157. #gen_SendLiteralSelector1ArgBytecode13.
		  #isMapped }.
		  { 1. 158. 158. #gen_SendLiteralSelector1ArgBytecode14.
		  #isMapped }.
		  { 1. 159. 159. #gen_SendLiteralSelector1ArgBytecode15.
		  #isMapped }.
		  { 1. 160. 160. #gen_SendLiteralSelector2ArgsBytecode0.
		  #isMapped }.
		  { 1. 161. 161. #gen_SendLiteralSelector2ArgsBytecode1.
		  #isMapped }.
		  { 1. 162. 162. #gen_SendLiteralSelector2ArgsBytecode2.
		  #isMapped }.
		  { 1. 163. 163. #gen_SendLiteralSelector2ArgsBytecode3.
		  #isMapped }.
		  { 1. 164. 164. #gen_SendLiteralSelector2ArgsBytecode4.
		  #isMapped }.
		  { 1. 165. 165. #gen_SendLiteralSelector2ArgsBytecode5.
		  #isMapped }.
		  { 1. 166. 166. #gen_SendLiteralSelector2ArgsBytecode6.
		  #isMapped }.
		  { 1. 167. 167. #gen_SendLiteralSelector2ArgsBytecode7.
		  #isMapped }.
		  { 1. 168. 168. #gen_SendLiteralSelector2ArgsBytecode8.
		  #isMapped }.
		  { 1. 169. 169. #gen_SendLiteralSelector2ArgsBytecode9.
		  #isMapped }.
		  { 1. 170. 170. #gen_SendLiteralSelector2ArgsBytecode10.
		  #isMapped }.
		  { 1. 171. 171. #gen_SendLiteralSelector2ArgsBytecode11.
		  #isMapped }.
		  { 1. 172. 172. #gen_SendLiteralSelector2ArgsBytecode12.
		  #isMapped }.
		  { 1. 173. 173. #gen_SendLiteralSelector2ArgsBytecode13.
		  #isMapped }.
		  { 1. 174. 174. #gen_SendLiteralSelector2ArgsBytecode14.
		  #isMapped }.
		  { 1. 175. 175. #gen_SendLiteralSelector2ArgsBytecode15.
		  #isMapped }.
		  { 1. 176. 176. #gen_ShortUnconditionalJump0.
		  #branch. #v3:ShortForward:Branch:Distance: }.
		  { 1. 177. 177. #gen_ShortUnconditionalJump1.
		  #branch. #v3:ShortForward:Branch:Distance: }.
		  { 1. 178. 178. #gen_ShortUnconditionalJump2.
		  #branch. #v3:ShortForward:Branch:Distance: }.
		  { 1. 179. 179. #gen_ShortUnconditionalJump3.
		  #branch. #v3:ShortForward:Branch:Distance: }.
		  { 1. 180. 180. #gen_ShortUnconditionalJump4.
		  #branch. #v3:ShortForward:Branch:Distance: }.
		  { 1. 181. 181. #gen_ShortUnconditionalJump5.
		  #branch. #v3:ShortForward:Branch:Distance: }.
		  { 1. 182. 182. #gen_ShortUnconditionalJump6.
		  #branch. #v3:ShortForward:Branch:Distance: }.
		  { 1. 183. 183. #gen_ShortUnconditionalJump7.
		  #branch. #v3:ShortForward:Branch:Distance: }.
		  { 1. 184. 184. #gen_ShortConditionalJumpTrue0.
		  #branch. #isBranchTrue. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 185. 185. #gen_ShortConditionalJumpTrue1.
		  #branch. #isBranchTrue. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 186. 186. #gen_ShortConditionalJumpTrue2.
		  #branch. #isBranchTrue. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 187. 187. #gen_ShortConditionalJumpTrue3.
		  #branch. #isBranchTrue. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 188. 188. #gen_ShortConditionalJumpTrue4.
		  #branch. #isBranchTrue. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 189. 189. #gen_ShortConditionalJumpTrue5.
		  #branch. #isBranchTrue. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 190. 190. #gen_ShortConditionalJumpTrue6.
		  #branch. #isBranchTrue. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 191. 191. #gen_ShortConditionalJumpTrue7.
		  #branch. #isBranchTrue. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 192. 192. #gen_ShortConditionalJumpFalse0.
		  #branch. #isBranchFalse. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 193. 193. #gen_ShortConditionalJumpFalse1.
		  #branch. #isBranchFalse. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 194. 194. #gen_ShortConditionalJumpFalse2.
		  #branch. #isBranchFalse. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 195. 195. #gen_ShortConditionalJumpFalse3.
		  #branch. #isBranchFalse. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 196. 196. #gen_ShortConditionalJumpFalse4.
		  #branch. #isBranchFalse. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 197. 197. #gen_ShortConditionalJumpFalse5.
		  #branch. #isBranchFalse. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 198. 198. #gen_ShortConditionalJumpFalse6.
		  #branch. #isBranchFalse. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 199. 199. #gen_ShortConditionalJumpFalse7.
		  #branch. #isBranchFalse. #isMapped. #v3:ShortForward:Branch:Distance: }.
		  { 1. 200. 200. #gen_StoreAndPopReceiverVariableBytecode0.
		  #isInstVarRef. #isMappedIfImmutability. #needsFrameIfImmutability:.
		   -1 }.
		  { 1. 201. 201. #gen_StoreAndPopReceiverVariableBytecode1.
		  #isInstVarRef. #isMappedIfImmutability. #needsFrameIfImmutability:.
		   -1 }.
		  { 1. 202. 202. #gen_StoreAndPopReceiverVariableBytecode2.
		  #isInstVarRef. #isMappedIfImmutability. #needsFrameIfImmutability:.
		   -1 }.
		  { 1. 203. 203. #gen_StoreAndPopReceiverVariableBytecode3.
		  #isInstVarRef. #isMappedIfImmutability. #needsFrameIfImmutability:.
		   -1 }.
		  { 1. 204. 204. #gen_StoreAndPopReceiverVariableBytecode4.
		  #isInstVarRef. #isMappedIfImmutability. #needsFrameIfImmutability:.
		   -1 }.
		  { 1. 205. 205. #gen_StoreAndPopReceiverVariableBytecode5.
		  #isInstVarRef. #isMappedIfImmutability. #needsFrameIfImmutability:.
		   -1 }.
		  { 1. 206. 206. #gen_StoreAndPopReceiverVariableBytecode6.
		  #isInstVarRef. #isMappedIfImmutability. #needsFrameIfImmutability:.
		   -1 }.
		  { 1. 207. 207. #gen_StoreAndPopReceiverVariableBytecode7.
		  #isInstVarRef. #isMappedIfImmutability. #needsFrameIfImmutability:.
		   -1 }.
		  { 1. 208. 208. #gen_StoreAndPopTemporaryVariableBytecode0 }.
		  { 1. 209. 209. #gen_StoreAndPopTemporaryVariableBytecode1 }.
		  { 1. 210. 210. #gen_StoreAndPopTemporaryVariableBytecode2 }.
		  { 1. 211. 211. #gen_StoreAndPopTemporaryVariableBytecode3 }.
		  { 1. 212. 212. #gen_StoreAndPopTemporaryVariableBytecode4 }.
		  { 1. 213. 213. #gen_StoreAndPopTemporaryVariableBytecode5 }.
		  { 1. 214. 214. #gen_StoreAndPopTemporaryVariableBytecode6 }.
		  { 1. 215. 215. #gen_StoreAndPopTemporaryVariableBytecode7 }.
		  { 1. 216. 216. #gen_PopStackBytecode. #needsFrameNever:.
		   -1 }.
		  { 1. 217. 217. #unknownBytecode }.
		  { 1. 218. 218. #unknownBytecode }.
		  { 1. 219. 219. #unknownBytecode }.
		  { 1. 220. 220. #unknownBytecode }.
		  { 1. 221. 221. #unknownBytecode }.
		  { 1. 222. 222. #unknownBytecode }.
		  { 1. 223. 223. #unknownBytecode }.
		  { 2. 224. 224. #gen_ExtABytecode. #extension }.
		  { 2. 225. 225. #gen_ExtBBytecode. #extension }.
		  { 2. 226. 226. #gen_ExtPushReceiverVariableBytecode.
		  #isInstVarRef. #isMappedIfImmutability }.
		  { 2. 227. 227. #gen_ExtPushLiteralVariableBytecode.
		  #needsFrameNever:. 1 }.
		  { 2. 228. 228. #gen_ExtPushLiteralBytecode.
		  #needsFrameNever:. 1 }.
		  { 2. 229. 229. #gen_LongPushTemporaryVariableBytecode }.
		  { 2. 230. 230. #unknownBytecode }.
		  { 2. 231. 231. #gen_PushNewArrayBytecode }.
		  { 2. 232. 232. #gen_ExtPushIntegerBytecode.
		  #needsFrameNever:. 1 }.
		  { 2. 233. 233. #gen_ExtPushCharacterBytecode.
		  #needsFrameNever:. 1 }.
		  { 2. 234. 234. #gen_ExtSendBytecode. #isMapped }.
		  { 2. 235. 235. #gen_ExtSendSuperBytecode. #isMapped }.
		  { 2. 236. 236. #unknownBytecode }.
		  { 2. 237. 237. #gen_ExtUnconditionalJump. #branch. #isMapped.
		  #v4:Long:Branch:Distance: }.
		  { 2. 238. 238. #gen_ExtJumpIfTrue. #branch. #isBranchTrue.
		  #isMapped. #v4:Long:Branch:Distance: }.
		  { 2. 239. 239. #gen_ExtJumpIfFalse. #branch. #isBranchFalse.
		  #isMapped. #v4:Long:Branch:Distance: }.
		  { 2. 240. 240. #gen_ExtStoreAndPopReceiverVariableBytecode.
		  #isInstVarRef. #isMappedIfImmutability }.
		  { 2. 241. 241. #gen_ExtStoreAndPopLiteralVariableBytecode.
		  #isMappedIfImmutability }.
		  { 2. 242. 242. #gen_LongStoreAndPopTemporaryVariableBytecode }.
		  { 2. 243. 243. #gen_ExtStoreReceiverVariableBytecode.
		  #isInstVarRef. #isMappedIfImmutability. #needsFrameIfImmutability:.
		  0 }.
		  { 2. 244. 244. #gen_ExtStoreLiteralVariableBytecode.
		  #isMappedIfImmutability }.
		  { 2. 245. 245. #gen_LongStoreTemporaryVariableBytecode }.
		  { 2. 246. 246. #unknownBytecode }.
		  { 2. 247. 247. #unknownBytecode }.
		  { 3. 248. 248. #gen_CallPrimitiveBytecode }.
		  { 3. 249. 249. #gen_ExtPushFullClosureBytecode }.
		  { 3. 250. 250. #unknownBytecode }.
		  { 3. 251. 251. #gen_PushRemoteTempLongBytecode }.
		  { 3. 252. 252. #gen_StoreRemoteTempLongBytecode.
		  #isMappedIfImmutability. #needsFrameIfImmutability:.
		  0 }.
		  { 3. 253. 253. #gen_StoreAndPopRemoteTempLongBytecode.
		  #isMappedIfImmutability. #needsFrameIfImmutability:.
		   -1 }.
		  { 3. 254. 254. #unknownBytecode }.
		  { 3. 255. 255. #unknownBytecode } }
]

{ #category : #'class initialization' }
DruidStaticTypePredictionJIT class >> initializeBytecodeTableForSistaV1 [

	<generated>
	numPushNilsFunction := #sistaV1:Num:Push:Nils:.
	pushNilSizeFunction := #sistaV1PushNilSize:numInitialNils:.
	BytecodeSetHasDirectedSuperSend := true.
	BytecodeSetHasExtensions := true.
	FirstSpecialSelector := 96.
	NumSpecialSelectors := 32.
	self generatorTableFrom: self bytecodeTable
]

{ #category : #'class initialization' }
DruidStaticTypePredictionJIT class >> initializePrimitiveTable [

	<generated>
	MaxCompiledPrimitiveIndex := 550.
	primitiveTable := CArrayAccessor on:
		                  (Array new: MaxCompiledPrimitiveIndex + 1).
	self table: primitiveTable from: self primitiveTableArray.
	^ primitiveTable
]

{ #category : #'class initialization' }
DruidStaticTypePredictionJIT class >> primitiveTableArray [

	<generated>
	^ {
		  { 1. #gen_PrimitiveAdd. 1 }.
		  { 2. #gen_PrimitiveSubtract. 1 }.
		  { 3. #gen_PrimitiveLessThan. 1 }.
		  { 4. #gen_PrimitiveGreaterThan. 1 }.
		  { 5. #gen_PrimitiveLessOrEqual. 1 }.
		  { 6. #gen_PrimitiveGreaterOrEqual. 1 }.
		  { 7. #gen_PrimitiveEqual. 1 }.
		  { 8. #gen_PrimitiveNotEqual. 1 }.
		  { 9. #gen_PrimitiveMultiply. 1 }.
		  { 10. #gen_PrimitiveDivide. 1 }.
		  { 11. #gen_PrimitiveMod. 1 }.
		  { 12. #gen_PrimitiveDiv. 1 }.
		  { 13. #gen_PrimitiveQuo. 1 }.
		  { 14. #gen_PrimitiveBitAnd. 1 }.
		  { 15. #gen_PrimitiveBitOr. 1 }.
		  { 16. #gen_PrimitiveBitXor. 1 }.
		  { 17. #gen_PrimitiveBitShift. 1 }.
		  { 40. #gen_PrimitiveAsFloat. 0 }.
		  { 41. #gen_PrimitiveFloatAdd. 1 }.
		  { 42. #gen_PrimitiveFloatSubtract. 1 }.
		  { 43. #gen_PrimitiveFloatLessThan. 1 }.
		  { 44. #gen_PrimitiveFloatGreaterThan.
		  1 }.
		  { 45. #gen_PrimitiveFloatLessOrEqual.
		  1 }.
		  { 46. #gen_PrimitiveFloatGreaterOrEqual.
		  1 }.
		  { 47. #gen_PrimitiveFloatEqual. 1 }.
		  { 48. #gen_PrimitiveFloatNotEqual. 1 }.
		  { 49. #gen_PrimitiveFloatMultiply. 1 }.
		  { 60. #gen_PrimitiveAt. 1 }.
		  { 61. #gen_PrimitiveAtPut. 2 }.
		  { 62. #gen_PrimitiveSize. 0 }.
		  { 63. #gen_PrimitiveStringAt. 1 }.
		  { 64. #gen_PrimitiveStringAtPut. 2 }.
		  { 70. #gen_PrimitiveNew. 0 }.
		  { 71. #gen_PrimitiveNewWithArg. 1 }.
		  { 73. #genNonImplementedPrimitive.  -1. #maycallback }.
		  { 75. #gen_PrimitiveIdentityHash. 0 }.
		  { 110. #gen_PrimitiveIdentical. 1 }.
		  { 111. #gen_PrimitiveClass }.
		  { 117. #genNonImplementedPrimitive.  -1. #maycallback }.
		  { 120. #genNonImplementedPrimitive.  -1. #maycallback }.
		  { 148. #genNonImplementedPrimitive.  -1. #maycallback }.
		  { 160. #genNonImplementedPrimitive.  -1. #maycallback }.
		  { 169. #gen_PrimitiveNotIdentical. 1 }.
		  { 170. #gen_PrimitiveAsCharacter }.
		  { 171. #gen_PrimitiveImmediateAsInteger }.
		  { 173. #genNonImplementedPrimitive.  -1. #maycallback }.
		  { 207. #gen_PrimitiveFullClosureValue }.
		  { 209. #gen_PrimitiveFullClosureValueNoContextSwitch }.
		  { 216. #genNonImplementedPrimitive.  -1. #maycallback }.
		  { 541. #gen_PrimitiveSmallFloatAdd. 1 }.
		  { 542. #gen_PrimitiveSmallFloatSubtract.
		  1 }.
		  { 543. #gen_PrimitiveSmallFloatLessThan.
		  1 }.
		  { 544. #gen_PrimitiveSmallFloatGreaterThan.
		  1 }.
		  { 545. #gen_PrimitiveSmallFloatLessOrEqual.
		  1 }.
		  { 546. #gen_PrimitiveSmallFloatGreaterOrEqual.
		  1 }.
		  { 547. #gen_PrimitiveSmallFloatEqual. 1 }.
		  { 548. #gen_PrimitiveSmallFloatNotEqual.
		  1 }.
		  { 549. #gen_PrimitiveSmallFloatMultiply.
		  1 }.
		  { 550. #gen_PrimitiveSmallFloatDivide.
		  1 } }
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimAdd [
	"AutoGenerated by Druid"

	| t0 jump3 jump1 t1 currentBlock jump2 live t2 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 1) copyToReg: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveR: t0 R: t2.
	self AndR: t1 R: t2.
	self TstCq: 1 R: t2.
	jump1 := self JumpZero: 0.
	self AddCq:  -1 R: t0.
	self AddR: t1 R: t0.
	jump2 := self JumpOverflow: 0.
	self ssUnspillStackSlotAt: 0.
	self ssUnspillStackSlotAt: 1.
	self MoveR: t0 R: t2.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -1
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self MoveR: ReceiverResultReg R: t2.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: t2.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimAt [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -17
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimAtEnd [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: -22
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimAtPut [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: -18
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimBitAnd [
	"AutoGenerated by Druid"

	| t0 jump1 t1 currentBlock jump2 live t2 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 1) copyToReg: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveR: t0 R: t2.
	self AndR: t1 R: t2.
	self TstCq: 1 R: t2.
	jump1 := self JumpZero: 0.
	self AndR: t1 R: t0.
	self ssUnspillStackSlotAt: 0.
	self ssUnspillStackSlotAt: 1.
	self MoveR: t0 R: t2.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -15
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self MoveR: ReceiverResultReg R: t2.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: t2.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimBitOr [
	"AutoGenerated by Druid"

	| t0 jump1 t1 currentBlock jump2 live t2 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 1) copyToReg: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveR: t0 R: t2.
	self AndR: t1 R: t2.
	self TstCq: 1 R: t2.
	jump1 := self JumpZero: 0.
	self OrR: t1 R: t0.
	self ssUnspillStackSlotAt: 0.
	self ssUnspillStackSlotAt: 1.
	self MoveR: t0 R: t2.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -16
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self MoveR: ReceiverResultReg R: t2.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: t2.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimBitShift [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -13
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimDiv [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -14
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimDivide [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -10
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimDo [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -28
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimEqualSistaV1 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -7
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimGreaterOrEqualSistaV1 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -6
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimGreaterThanSistaV1 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -4
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimIdenticalSistaV1 [
	"AutoGenerated by Druid"

	| jump1 s57 s54 t1 jump6 jump3 currentBlock t3 t0 jump5 jump2 b498 b502 live t2 jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 1) copyToReg: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b502 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b502.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t2 R: t0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t2.
	b498 := self Label.
	t3 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t3).
	self MoveR: t2 R: t3.
	self AndCq: 7 R: t3.
	self CmpCq: 0 R: t3.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t3.
	self AndCq: 16r3FFFF7 R: t3.
	self CmpCq: 0 R: t3.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t3.
	self MoveR: t3 R: t2.
	jump6 := self Jump: b498.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t2 R: t3.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	self MoveR: t1 R: t3.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	self CmpR: t3 R: t0.
	jump3 := self JumpNonZero: 0.
	s54 := objectMemory trueObject.
	self MoveCq: s54 R: t3.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s57 := objectMemory falseObject.
	self MoveCq: s57 R: t3.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 0 R: t3.
	jump2 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self ssPushRegister: t3.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimLessOrEqualSistaV1 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -5
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimLessThanSistaV1 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -3
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimMakePoint [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -12
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimMod [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -11
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimMultiply [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -9
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimNew [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: -29
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimNewWithArg [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -30
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimNext [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: -20
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimNextPut [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -21
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimNotEqualSistaV1 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -8
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimNotIdenticalSistaV1 [
	"AutoGenerated by Druid"

	| jump1 s57 s54 t1 jump6 jump3 currentBlock t3 t0 jump5 jump2 b498 b502 live t2 jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 1) copyToReg: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t2.
	b502 := self Label.
	self MoveR: t2 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t0.
	self MoveR: t0 R: t2.
	jump5 := self Jump: b502.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: t2 R: t0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t2.
	b498 := self Label.
	t3 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t3).
	self MoveR: t2 R: t3.
	self AndCq: 7 R: t3.
	self CmpCq: 0 R: t3.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t3.
	self AndCq: 16r3FFFF7 R: t3.
	self CmpCq: 0 R: t3.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t3.
	self MoveR: t3 R: t2.
	jump6 := self Jump: b498.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t2 R: t3.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	self MoveR: t1 R: t3.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: true.
	self CmpR: t3 R: t0.
	jump3 := self JumpZero: 0.
	s54 := objectMemory trueObject.
	self MoveCq: s54 R: t3.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s57 := objectMemory falseObject.
	self MoveCq: s57 R: t3.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 0 R: t3.
	jump2 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self ssPushRegister: t3.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimPointX [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: -31
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimPointY [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: -32
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimSize [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: -19
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimSubtract [
	"AutoGenerated by Druid"

	| t0 jump3 jump1 t1 currentBlock jump2 live t2 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 1) copyToReg: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveR: t0 R: t2.
	self AndR: t1 R: t2.
	self TstCq: 1 R: t2.
	jump1 := self JumpZero: 0.
	self ArithmeticShiftRightCq: 3 R: t0.
	self MoveR: t1 R: t2.
	self ArithmeticShiftRightCq: 3 R: t2.
	self SubR: t2 R: t0.
	self MoveR: t0 R: t2.
	self LogicalShiftRightCq: 60 R: t2.
	self AddCq: 1 R: t2.
	self AndCq: 15 R: t2.
	self CmpCq: 1 R: t2.
	jump2 := self JumpAbove: 0.
	self MoveR: t0 R: t2.
	self LogicalShiftLeftCq: 3 R: t2.
	self AddCq: 1 R: t2.
	self ssUnspillStackSlotAt: 0.
	self ssUnspillStackSlotAt: 1.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -2
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self MoveR: ReceiverResultReg R: t2.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self ssPop: 2 popSpilled: false.
	self ssPushRegister: t2.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimValue [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: -26
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_BytecodePrimValueWithArg [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: -27
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_CallPrimitiveBytecode [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_DuplicateTopBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtABytecode [
	"AutoGenerated by Druid"

	| s5 s4 s2 currentBlock live s3 |
	live := 0.
	s2 := extA.
	s3 := s2 << 8.
	s4 := byte1.
	s5 := s3 + s4.
	extA := s5.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtBBytecode [
	"AutoGenerated by Druid"

	| s6 s24 s16 s4 s22 s14 s9 s2 s20 currentBlock s12 s25 s17 live s5 s3 s21 s13 s8 |
	live := 0.
	s2 := byte1.
	s3 := numExtB.
	s3 = 0 ifTrue: [
		s2 > 127 ifTrue: [
			s6 := s2 - 256.
			extB := s6.
			s8 := numExtB.
			s9 := s8 + 1.
			numExtB := s9.
			^ 0 ].
		s12 := extB.
		s13 := s12 << 8.
		s14 := s13 + s2.
		extB := s14.
		s16 := numExtB.
		s17 := s16 + 1.
		numExtB := s17.
		^ 0 ].
	s20 := extB.
	s21 := s20 << 8.
	s22 := s21 + s2.
	extB := s22.
	s24 := numExtB.
	s25 := s24 + 1.
	numExtB := s25.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtJumpIfFalse [
	"AutoGenerated by Druid"

	| s6 s3 jump1 s16 jump3 s5 s2 s18 s15 currentBlock s12 t0 jump2 s4 s17 live s20 |
	live := 0.
	self annotateBytecode: self Label.
	s3 := byte1.
	s4 := extB.
	s5 := s4 << 8.
	s6 := s3 + s5.
	extA := 0.
	extB := 0.
	numExtB := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s12 := objectMemory falseObject.
	self ssFlushStack.
	self CmpCq: s12 R: t0.
	jump1 := self JumpNonZero: 0.
	s15 := bytecodePC.
	s16 := s15 + s6.
	s17 := s16 + 2.
	self Jump: (self ensureFixupAt: s17).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s20 := objectMemory trueObject.
	self CmpCq: s20 R: t0.
	jump1 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtJumpIfTrue [
	"AutoGenerated by Druid"

	| s6 s3 jump1 s16 jump3 s5 s2 s18 s15 currentBlock s12 t0 jump2 s4 s17 live s20 |
	live := 0.
	self annotateBytecode: self Label.
	s3 := byte1.
	s4 := extB.
	s5 := s4 << 8.
	s6 := s3 + s5.
	extA := 0.
	extB := 0.
	numExtB := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s12 := objectMemory trueObject.
	self ssFlushStack.
	self CmpCq: s12 R: t0.
	jump1 := self JumpNonZero: 0.
	s15 := bytecodePC.
	s16 := s15 + s6.
	s17 := s16 + 2.
	self Jump: (self ensureFixupAt: s17).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s20 := objectMemory falseObject.
	self CmpCq: s20 R: t0.
	jump1 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtNopBytecode [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	extB := 0.
	extA := 0.
	numExtB := 0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtPushCharacterBytecode [
	"AutoGenerated by Druid"

	| s5 s6 s4 s2 currentBlock s7 live s3 |
	live := 0.
	s2 := byte1.
	s3 := extB.
	s4 := s3 << 8.
	s5 := s2 + s4.
	s6 := s5 << 3.
	s7 := s6 + 2.
	self ssPushConstant: s7.
	extB := 0.
	numExtB := 0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtPushFullClosureBytecode [
	"AutoGenerated by Druid"

	| b4 s24 s4 t3 s9 s2 s20 currentBlock s27 s19 s12 s7 s36 t1 s17 live s5 s15 s3 s37 t2 s8 t0 s18 s11 |
	live := 0.
	s2 := byte1.
	s3 := extA.
	s4 := s3 << 8.
	s5 := s2 + s4.
	extA := 0.
	s7 := byte2.
	s8 := s7 bitAnd: 63.
	s9 := s7 anyMask: 64.
	live := live bitOr: (self registerMaskFor: ReceiverResultReg).
	live := live bitOr: (self registerMaskFor: SendNumArgsReg).
	live := live bitOr: (self registerMaskFor: ClassReg).
	self voidReceiverResultRegContainsSelf.
	self
		ssAllocateCallReg: ReceiverResultReg
		and: SendNumArgsReg
		and: ClassReg.
	self
		genCreateFullClosureInIndex: s5
		numCopied: s8
		ignoreContext: s9
		contextNumArgs: methodOrBlockNumArgs
		large: (coInterpreter methodNeedsLargeContext: methodObj)
		inBlock: inBlock
		intoRegister: ReceiverResultReg.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	s11 := 1.
	s12 := s11.
	b4 := self Label.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	[ ((s12<=s8)) ] whileTrue: [
		(self ssValue: 0) copyToReg: t1.
		s17 := FullClosureFirstCopiedValueIndex.
		s18 := s17 + s8.
		s19 := s18 - s12.
		s20 := s19 << 3.
		self MoveR: t0 R: t2.
		self AddCq: s20 R: t2.
		self MoveR: t1 M64: 8 r: t2.
		s24 := s12 + 1.
		s12 := s24 ].
	t3 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t3).
	(s7 anyMask: 128) ifTrue: [
		(self ssValue: 0) copyToReg: t3.
		self MoveR: t3 R: t2.
		self ssPop: 1 popSpilled: true.
		s36 := FullClosureReceiverIndex.
		s37 := s36 << 3.
		self MoveR: t0 R: t1.
		self AddCq: s37 R: t1.
		self MoveR: t2 M64: 8 r: t1.
		self ssPushRegister: t0.
		^ 0 ].
	self ensureReceiverResultRegContainsSelf.
	self MoveR: ReceiverResultReg R: t2.
	self ssPop: 1 popSpilled: true.
	s36 := FullClosureReceiverIndex.
	s37 := s36 << 3.
	self MoveR: t0 R: t1.
	self AddCq: s37 R: t1.
	self MoveR: t2 M64: 8 r: t1.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtPushIntegerBytecode [
	"AutoGenerated by Druid"

	| s5 s8 s4 s2 currentBlock s9 s10 live s3 |
	live := 0.
	s2 := byte1.
	s3 := extB.
	s4 := s3 << 8.
	s5 := s2 + s4.
	extB := 0.
	numExtB := 0.
	s8 := s2 + s4.
	s9 := s8 << 3.
	s10 := s9 + 1.
	self ssPushConstant: s10.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtPushLiteralBytecode [
	"AutoGenerated by Druid"

	| s3 s10 s8 s5 s2 currentBlock t0 s4 live s9 |
	live := 0.
	s2 := byte1.
	s3 := extA.
	s4 := s3 << 8.
	s5 := s2 + s4.
	extA := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s8 := LiteralStart.
	s9 := s5 + s8.
	s10 := s9 << 3.
	self AddCq: s10 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtPushLiteralVariableBytecode [
	"AutoGenerated by Druid"

	| s34 s3 jump1 jump4 s10 t1 s8 s5 s2 jump3 currentBlock t0 s35 s4 jump2 b233 live s9 |
	live := 0.
	s2 := byte1.
	s3 := extA.
	s4 := s3 << 8.
	s5 := s2 + s4.
	extA := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s8 := LiteralStart.
	s9 := s5 + s8.
	s10 := s9 << 3.
	self AddCq: s10 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s34 := ValueIndex.
	s35 := s34 << 3.
	self AddCq: s35 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtPushReceiverVariableBytecode [
	"AutoGenerated by Druid"

	| s6 s3 s13 s10 t1 s5 s2 s18 currentBlock t0 s4 live s9 |
	live := 0.
	self annotateBytecode: self Label.
	s3 := byte1.
	s4 := extA.
	s5 := s4 << 8.
	s6 := s3 + s5.
	extA := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	s9 := StackPointerIndex.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	s6 <= s9 ifTrue: [
		| jump1 jump2 |
		self MoveM64: 0 r: t0 R: t1.
		self AndCq: 16r3FFFFF R: t1.
		s13 := ClassMethodContextCompactIndex.
		self CmpCq: s13 R: t1.
		jump1 := self JumpNonZero: 0.
		self ssFlushStack.
		self deoptimize.
		jump2 := self Jump: 0.
		deadCode := false.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		s18 := s6 << 3.
		self AddCq: s18 R: t0.
		self ssPushBase: t0 offset: 8.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		^ 0 ].
	s18 := s6 << 3.
	self AddCq: s18 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtSendBytecode [
	"AutoGenerated by Druid"

	| s6 s3 s10 s8 s5 s2 currentBlock s4 live s11 s9 |
	live := 0.
	s2 := byte1.
	s3 := s2 >> 3.
	s4 := extA.
	s5 := s4 << 5.
	s6 := s3 + s5.
	extA := 0.
	s8 := s2 bitAnd: 7.
	s9 := extB.
	s10 := s9 << 3.
	s11 := s8 + s10.
	extB := 0.
	numExtB := 0.
	self marshallSendArguments: s11.
	self
		genMarshalledSendNoPush: s6
		numArgs: s11
		sendTable: ordinarySendTrampolines.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtSendSuperBytecode [
	"AutoGenerated by Druid"

	| s6 s3 s16 s10 s8 s5 s2 s18 currentBlock s15 s4 s17 live s11 s9 |
	live := 0.
	s2 := byte1.
	s3 := s2 >> 3.
	s4 := extA.
	s5 := s4 << 5.
	s6 := s3 + s5.
	extA := 0.
	s8 := BytecodeSetHasDirectedSuperSend.
	s8 ifTrue: [
		s10 := extB.
		s10 >= 64 ifTrue: [
			self ssFlushStack.
			self deoptimize.
			^ 0 ].
		s15 := s2 bitAnd: 7.
		s16 := extB.
		s17 := s16 << 3.
		s18 := s15 + s17.
		extB := 0.
		numExtB := 0.
		self marshallSendArguments: s18.
		self
			genMarshalledSendNoPush: s6
			numArgs: s18
			sendTable: superSendTrampolines.
		self ssPushConstant: ReceiverResultReg.
		^ 0 ].
	s15 := s2 bitAnd: 7.
	s16 := extB.
	s17 := s16 << 3.
	s18 := s15 + s17.
	extB := 0.
	numExtB := 0.
	self marshallSendArguments: s18.
	self
		genMarshalledSendNoPush: s6
		numArgs: s18
		sendTable: superSendTrampolines.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtStoreAndPopLiteralVariableBytecode [
	"AutoGenerated by Druid"

	| jump6 t2 s56 jump7 s95 jump8 s83 s104 jump9 s97 s59 s2 jumpTrue s108 s3 s4 s89 s48 live s5 s61 s6 s37 b623 s78 s11 s112 s12 jump1 s51 s13 jump2 jump3 jump4 t0 currentBlock jump5 t1 jumpNext s101 |
	live := 0.
	self annotateBytecode: self Label.
	s3 := byte1.
	s4 := extA.
	s5 := s4 << 8.
	s6 := s3 + s5.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	extA := 0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self genMoveConstant: methodObj R: t1.
	s11 := LiteralStart.
	s12 := s6 + s11.
	s13 := s12 << 3.
	self AddCq: s13 R: t1.
	self MoveM64: 8 r: t1 R: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t1 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t2.
	b623 := self Label.
	self MoveR: t2 R: t1.
	self AndCq: 7 R: t1.
	self CmpCq: 0 R: t1.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t1.
	self MoveR: t1 R: t2.
	jump4 := self Jump: b623.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t2 R: t1.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s37 := ValueIndex.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump3 := self JumpZero: 0.
	self deoptimize.
	jump1 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	s48 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s48 R: t2.
	s51 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s51 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump5 := self JumpNonZero: 0.
	s56 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s56 R: t2.
	s59 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s59 R: t2.
	jump6 := self JumpNonZero: 0.
	s61 := objectMemory getMemoryMap getNewSpaceStart.
	self MoveR: t0 R: t2.
	self CmpCq: s61 R: t2.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump8 := self JumpNonZero: 0.
	self MoveR: t1 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump9 := self JumpZero: 0.
	s78 := s37 << 3.
	self AddCq: s78 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self TstCq: 7 R: t0.
	jump9 := self JumpZero: 0.
	s83 := s37 << 3.
	self AddCq: s83 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 16r20000000000 R: t1.
	jump9 := self JumpBelow: 0.
	self CmpCq: 16r20000000000 R: t0.
	jump5 := self JumpLess: 0.
	s89 := s37 << 3.
	self AddCq: s89 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t0.
	jump5 := self JumpBelow: 0.
	s95 := objectMemory trueObject.
	self CmpCq: s95 R: t0.
	jump3 := self JumpAbove: 0.
	s97 := s37 << 3.
	self AddCq: s97 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	s101 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s101 R: t0.
	jump3 := self JumpBelow: 0.
	self MoveR: t1 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	s104 := s37 << 3.
	self AddCq: s104 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s108 := s37 << 3.
	self AddCq: s108 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	s112 := s37 << 3.
	self AddCq: s112 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtStoreAndPopReceiverVariableBytecode [
	"AutoGenerated by Druid"

	| s6 jump5 s46 s4 s38 s103 jump3 s69 s14 s2 s9 currentBlock s49 t1 s51 s90 jump1 jump6 live s5 jump4 s93 s63 s3 s76 s85 t2 s98 jump9 jump7 jump2 t0 s83 s41 s11 |
	live := 0.
	self annotateBytecode: self Label.
	s3 := byte1.
	s4 := extA.
	s5 := s4 << 8.
	s6 := s3 + s5.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ensureReceiverResultRegContainsSelf.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self MoveR: ReceiverResultReg R: t1.
	s9 := ReceiverIndex.
	self ssFlushStack.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	s6 <= s9 ifTrue: [
		| jump7 jump5 jump3 jump1 jump8 jump6 jump4 jump2 jump9 |
		self MoveM64: 0 r: t1 R: t2.
		self AndCq: 16r3FFFFF R: t2.
		s14 := ClassMethodContextCompactIndex.
		self CmpCq: s14 R: t2.
		jump1 := self JumpNonZero: 0.
		self deoptimize.
		extA := 0.
		jump2 := self Jump: 0.
		deadCode := false.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self ssPop: 1 popSpilled: true.
		self MoveM64: 0 r: t1 R: t2.
		self LogicalShiftRightCq: 23 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump1 := self JumpZero: 0.
		self deoptimize.
		extA := 0.
		jump3 := self Jump: 0.
		deadCode := false.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self MoveR: t1 R: t2.
		self AndCq: 7 R: t2.
		self CmpCq: 0 R: t2.
		jump1 := self JumpNonZero: 0.
		s38 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveR: t1 R: t2.
		self AndCq: s38 R: t2.
		s41 := objectMemory getMemoryMap getOldSpaceMask.
		self CmpCq: s41 R: t2.
		jump4 := self JumpNonZero: 0.
		self MoveR: t0 R: t2.
		self AndCq: 7 R: t2.
		self CmpCq: 0 R: t2.
		jump5 := self JumpNonZero: 0.
		s46 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveR: t0 R: t2.
		self AndCq: s46 R: t2.
		s49 := objectMemory getMemoryMap getNewSpaceMask.
		self CmpCq: s49 R: t2.
		jump6 := self JumpNonZero: 0.
		s51 := objectMemory getMemoryMap getNewSpaceStart.
		self CmpCq: s51 R: t0.
		jump7 := self JumpBelow: 0.
		self MoveM64: 0 r: t1 R: t2.
		self LogicalShiftRightCq: 29 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump8 := self JumpNonZero: 0.
		self MoveR: t1 R: TempReg.
		backEnd saveAndRestoreLinkRegAround: [
			self CallRT: ceStoreCheckTrampoline ].
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		jump4 jmpTarget: currentBlock.
		jump5 jmpTarget: currentBlock.
		jump6 jmpTarget: currentBlock.
		jump7 jmpTarget: currentBlock.
		jump8 jmpTarget: currentBlock.
		self MoveM64: 0 r: t1 R: t2.
		self LogicalShiftRightCq: 29 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump8 := self JumpZero: 0.
		s63 := s6 << 3.
		self AddCq: s63 R: t1.
		self MoveR: t0 M64: 8 r: t1.
		extA := 0.
		jump7 := self Jump: 0.
		currentBlock := self Label.
		jump8 jmpTarget: currentBlock.
		self TstCq: 7 R: t0.
		jump8 := self JumpZero: 0.
		s69 := s6 << 3.
		self AddCq: s69 R: t1.
		self MoveR: t0 M64: 8 r: t1.
		extA := 0.
		jump6 := self Jump: 0.
		currentBlock := self Label.
		jump8 jmpTarget: currentBlock.
		self CmpCq: 16r20000000000 R: t1.
		jump8 := self JumpLess: 0.
		self CmpCq: 16r20000000000 R: t0.
		jump5 := self JumpLess: 0.
		s76 := s6 << 3.
		self AddCq: s76 R: t1.
		self MoveR: t0 M64: 8 r: t1.
		extA := 0.
		jump4 := self Jump: 0.
		currentBlock := self Label.
		jump5 jmpTarget: currentBlock.
		self genMoveConstant: objectMemory nilObject R: t2.
		self CmpR: t2 R: t0.
		jump5 := self JumpBelow: 0.
		s83 := objectMemory trueObject.
		self CmpCq: s83 R: t0.
		jump1 := self JumpAbove: 0.
		s85 := s6 << 3.
		self AddCq: s85 R: t1.
		self MoveR: t0 M64: 8 r: t1.
		extA := 0.
		jump9 := self Jump: 0.
		currentBlock := self Label.
		jump5 jmpTarget: currentBlock.
		jump1 jmpTarget: currentBlock.
		s90 := objectMemory getMemoryMap getNewSpaceStart.
		self CmpCq: s90 R: t0.
		jump1 := self JumpBelow: 0.
		self MoveR: t1 R: TempReg.
		backEnd saveAndRestoreLinkRegAround: [
			self CallRT: ceStoreCheckTrampoline ].
		s93 := s6 << 3.
		self AddCq: s93 R: t1.
		self MoveR: t0 M64: 8 r: t1.
		extA := 0.
		jump5 := self Jump: 0.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		s98 := s6 << 3.
		self AddCq: s98 R: t1.
		self MoveR: t0 M64: 8 r: t1.
		extA := 0.
		jump1 := self Jump: 0.
		currentBlock := self Label.
		jump8 jmpTarget: currentBlock.
		s103 := s6 << 3.
		self AddCq: s103 R: t1.
		self MoveR: t0 M64: 8 r: t1.
		extA := 0.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		jump3 jmpTarget: currentBlock.
		jump7 jmpTarget: currentBlock.
		jump6 jmpTarget: currentBlock.
		jump4 jmpTarget: currentBlock.
		jump9 jmpTarget: currentBlock.
		jump5 jmpTarget: currentBlock.
		jump1 jmpTarget: currentBlock.
		^ 0 ].
	self ssPop: 1 popSpilled: true.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	extA := 0.
	jump5 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s38 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s38 R: t2.
	s41 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s41 R: t2.
	jump9 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	s46 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s46 R: t2.
	s49 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s49 R: t2.
	jump6 := self JumpNonZero: 0.
	s51 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s51 R: t0.
	jump7 := self JumpBelow: 0.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpZero: 0.
	s63 := s6 << 3.
	self AddCq: s63 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	extA := 0.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self TstCq: 7 R: t0.
	jump3 := self JumpZero: 0.
	s69 := s6 << 3.
	self AddCq: s69 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	extA := 0.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 16r20000000000 R: t1.
	jump3 := self JumpLess: 0.
	self CmpCq: 16r20000000000 R: t0.
	jump4 := self JumpLess: 0.
	s76 := s6 << 3.
	self AddCq: s76 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	extA := 0.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t0.
	jump4 := self JumpBelow: 0.
	s83 := objectMemory trueObject.
	self CmpCq: s83 R: t0.
	jump1 := self JumpAbove: 0.
	s85 := s6 << 3.
	self AddCq: s85 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	extA := 0.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	s90 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s90 R: t0.
	jump1 := self JumpBelow: 0.
	self MoveR: t1 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	s93 := s6 << 3.
	self AddCq: s93 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	extA := 0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s98 := s6 << 3.
	self AddCq: s98 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	extA := 0.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s103 := s6 << 3.
	self AddCq: s103 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	extA := 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtStoreLiteralVariableBytecode [
	"AutoGenerated by Druid"

	| jump6 t2 s94 jump7 s82 s103 jump8 s96 s58 jump9 s107 s2 jumpTrue s3 s88 s47 s4 s60 s5 live s36 s6 b623 s77 s10 s111 s11 s50 s12 jump1 jump2 jump3 jump4 t0 currentBlock s100 jump5 t1 jumpNext s55 |
	live := 0.
	self annotateBytecode: self Label.
	s3 := byte1.
	s4 := extA.
	s5 := s4 << 8.
	s6 := s3 + s5.
	extA := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self genMoveConstant: methodObj R: t1.
	s10 := LiteralStart.
	s11 := s6 + s10.
	s12 := s11 << 3.
	self AddCq: s12 R: t1.
	self MoveM64: 8 r: t1 R: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t1 R: t2.
	self AndCq: 16r3FFFF7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t2.
	b623 := self Label.
	self MoveR: t2 R: t1.
	self AndCq: 7 R: t1.
	self CmpCq: 0 R: t1.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t2 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t2 R: t1.
	self MoveR: t1 R: t2.
	jump4 := self Jump: b623.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t2 R: t1.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s36 := ValueIndex.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump3 := self JumpZero: 0.
	self deoptimize.
	jump1 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	s47 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s47 R: t2.
	s50 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s50 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump5 := self JumpNonZero: 0.
	s55 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s55 R: t2.
	s58 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s58 R: t2.
	jump6 := self JumpNonZero: 0.
	s60 := objectMemory getMemoryMap getNewSpaceStart.
	self MoveR: t0 R: t2.
	self CmpCq: s60 R: t2.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump8 := self JumpNonZero: 0.
	self MoveR: t1 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump9 := self JumpZero: 0.
	s77 := s36 << 3.
	self AddCq: s77 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self TstCq: 7 R: t0.
	jump9 := self JumpZero: 0.
	s82 := s36 << 3.
	self AddCq: s82 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 16r20000000000 R: t1.
	jump9 := self JumpBelow: 0.
	self CmpCq: 16r20000000000 R: t0.
	jump5 := self JumpLess: 0.
	s88 := s36 << 3.
	self AddCq: s88 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t0.
	jump5 := self JumpBelow: 0.
	s94 := objectMemory trueObject.
	self CmpCq: s94 R: t0.
	jump3 := self JumpAbove: 0.
	s96 := s36 << 3.
	self AddCq: s96 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	s100 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s100 R: t0.
	jump3 := self JumpBelow: 0.
	self MoveR: t1 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	s103 := s36 << 3.
	self AddCq: s103 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s107 := s36 << 3.
	self AddCq: s107 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	s111 := s36 << 3.
	self AddCq: s111 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtStoreReceiverVariableBytecode [
	"AutoGenerated by Druid"

	| s6 jump5 s88 s81 s4 jump3 s44 s14 s9 s2 s36 currentBlock s49 s101 s67 t1 jump1 jump6 s47 live s5 s39 jump4 jump9 s3 t2 jump2 s91 s61 jump7 s74 s83 t0 s96 s11 |
	live := 0.
	self annotateBytecode: self Label.
	s3 := byte1.
	s4 := extA.
	s5 := s4 << 8.
	s6 := s3 + s5.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ensureReceiverResultRegContainsSelf.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self MoveR: ReceiverResultReg R: t1.
	s9 := ReceiverIndex.
	self ssFlushStack.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	s6 <= s9 ifTrue: [
		| jump7 jump5 jump3 jump1 jump8 jump6 jump4 jump2 jump9 |
		self MoveM64: 0 r: t1 R: t2.
		self AndCq: 16r3FFFFF R: t2.
		s14 := ClassMethodContextCompactIndex.
		self CmpCq: s14 R: t2.
		jump1 := self JumpNonZero: 0.
		self deoptimize.
		extA := 0.
		jump2 := self Jump: 0.
		deadCode := false.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self MoveM64: 0 r: t1 R: t2.
		self LogicalShiftRightCq: 23 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump1 := self JumpZero: 0.
		self deoptimize.
		extA := 0.
		jump3 := self Jump: 0.
		deadCode := false.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self MoveR: t1 R: t2.
		self AndCq: 7 R: t2.
		self CmpCq: 0 R: t2.
		jump1 := self JumpNonZero: 0.
		s36 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveR: t1 R: t2.
		self AndCq: s36 R: t2.
		s39 := objectMemory getMemoryMap getOldSpaceMask.
		self CmpCq: s39 R: t2.
		jump4 := self JumpNonZero: 0.
		self MoveR: t0 R: t2.
		self AndCq: 7 R: t2.
		self CmpCq: 0 R: t2.
		jump5 := self JumpNonZero: 0.
		s44 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveR: t0 R: t2.
		self AndCq: s44 R: t2.
		s47 := objectMemory getMemoryMap getNewSpaceMask.
		self CmpCq: s47 R: t2.
		jump6 := self JumpNonZero: 0.
		s49 := objectMemory getMemoryMap getNewSpaceStart.
		self CmpCq: s49 R: t0.
		jump7 := self JumpBelow: 0.
		self MoveM64: 0 r: t1 R: t2.
		self LogicalShiftRightCq: 29 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump8 := self JumpNonZero: 0.
		self MoveR: t1 R: TempReg.
		backEnd saveAndRestoreLinkRegAround: [
			self CallRT: ceStoreCheckTrampoline ].
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		jump4 jmpTarget: currentBlock.
		jump5 jmpTarget: currentBlock.
		jump6 jmpTarget: currentBlock.
		jump7 jmpTarget: currentBlock.
		jump8 jmpTarget: currentBlock.
		self MoveM64: 0 r: t1 R: t2.
		self LogicalShiftRightCq: 29 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump8 := self JumpZero: 0.
		s61 := s6 << 3.
		self AddCq: s61 R: t1.
		self MoveR: t0 M64: 8 r: t1.
		extA := 0.
		jump7 := self Jump: 0.
		currentBlock := self Label.
		jump8 jmpTarget: currentBlock.
		self TstCq: 7 R: t0.
		jump8 := self JumpZero: 0.
		s67 := s6 << 3.
		self AddCq: s67 R: t1.
		self MoveR: t0 M64: 8 r: t1.
		extA := 0.
		jump6 := self Jump: 0.
		currentBlock := self Label.
		jump8 jmpTarget: currentBlock.
		self CmpCq: 16r20000000000 R: t1.
		jump8 := self JumpLess: 0.
		self CmpCq: 16r20000000000 R: t0.
		jump5 := self JumpLess: 0.
		s74 := s6 << 3.
		self AddCq: s74 R: t1.
		self MoveR: t0 M64: 8 r: t1.
		extA := 0.
		jump4 := self Jump: 0.
		currentBlock := self Label.
		jump5 jmpTarget: currentBlock.
		self genMoveConstant: objectMemory nilObject R: t2.
		self CmpR: t2 R: t0.
		jump5 := self JumpBelow: 0.
		s81 := objectMemory trueObject.
		self CmpCq: s81 R: t0.
		jump1 := self JumpAbove: 0.
		s83 := s6 << 3.
		self AddCq: s83 R: t1.
		self MoveR: t0 M64: 8 r: t1.
		extA := 0.
		jump9 := self Jump: 0.
		currentBlock := self Label.
		jump5 jmpTarget: currentBlock.
		jump1 jmpTarget: currentBlock.
		s88 := objectMemory getMemoryMap getNewSpaceStart.
		self CmpCq: s88 R: t0.
		jump1 := self JumpBelow: 0.
		self MoveR: t1 R: TempReg.
		backEnd saveAndRestoreLinkRegAround: [
			self CallRT: ceStoreCheckTrampoline ].
		s91 := s6 << 3.
		self AddCq: s91 R: t1.
		self MoveR: t0 M64: 8 r: t1.
		extA := 0.
		jump5 := self Jump: 0.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		s96 := s6 << 3.
		self AddCq: s96 R: t1.
		self MoveR: t0 M64: 8 r: t1.
		extA := 0.
		jump1 := self Jump: 0.
		currentBlock := self Label.
		jump8 jmpTarget: currentBlock.
		s101 := s6 << 3.
		self AddCq: s101 R: t1.
		self MoveR: t0 M64: 8 r: t1.
		extA := 0.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		jump3 jmpTarget: currentBlock.
		jump7 jmpTarget: currentBlock.
		jump6 jmpTarget: currentBlock.
		jump4 jmpTarget: currentBlock.
		jump9 jmpTarget: currentBlock.
		jump5 jmpTarget: currentBlock.
		jump1 jmpTarget: currentBlock.
		^ 0 ].
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	extA := 0.
	jump5 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s36 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s36 R: t2.
	s39 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s39 R: t2.
	jump9 := self JumpNonZero: 0.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	s44 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s44 R: t2.
	s47 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s47 R: t2.
	jump6 := self JumpNonZero: 0.
	s49 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s49 R: t0.
	jump7 := self JumpBelow: 0.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveM64: 0 r: t1 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump3 := self JumpZero: 0.
	s61 := s6 << 3.
	self AddCq: s61 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	extA := 0.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self TstCq: 7 R: t0.
	jump3 := self JumpZero: 0.
	s67 := s6 << 3.
	self AddCq: s67 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	extA := 0.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 16r20000000000 R: t1.
	jump3 := self JumpLess: 0.
	self CmpCq: 16r20000000000 R: t0.
	jump4 := self JumpLess: 0.
	s74 := s6 << 3.
	self AddCq: s74 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	extA := 0.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t0.
	jump4 := self JumpBelow: 0.
	s81 := objectMemory trueObject.
	self CmpCq: s81 R: t0.
	jump1 := self JumpAbove: 0.
	s83 := s6 << 3.
	self AddCq: s83 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	extA := 0.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	s88 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s88 R: t0.
	jump1 := self JumpBelow: 0.
	self MoveR: t1 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	s91 := s6 << 3.
	self AddCq: s91 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	extA := 0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s96 := s6 << 3.
	self AddCq: s96 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	extA := 0.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s101 := s6 << 3.
	self AddCq: s101 R: t1.
	self MoveR: t0 M64: 8 r: t1.
	extA := 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ExtUnconditionalJump [
	"AutoGenerated by Druid"

	| s6 s24 s33 s4 s22 s31 s38 jump3 s9 s2 s20 currentBlock s36 s42 s12 s7 t1 jump1 s10 s5 s23 live s32 s3 s21 s37 jump2 s43 s8 t0 s18 s41 |
	live := 0.
	self annotateBytecode: self Label.
	s3 := byte1.
	s4 := extB.
	s5 := s4 << 8.
	s6 := s3 + s5.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	s6 < 0 ifTrue: [
		| jump1 jump2 jump3 |
		s8 := numExtB.
		s9 := s8 << 1.
		s10 := s9.
		extB := 0.
		numExtB := 0.
		s18 := s6 + s10.
		self ssFlushStack.
		s18 >= 0 ifTrue: [
			s21 := bytecodePC.
			s22 := s21 + s6.
			s23 := s22 + 2.
			self Jump: (self ensureFixupAt: s23).
			deadCode := true.
			^ 0 ].
		self MoveR: SPReg R: t0.
		self MoveAw: coInterpreter stackLimitAddress R: t1.
		self CmpR: t1 R: t0.
		jump1 := self JumpAboveOrEqual: 0.
		self CallRT: ceCheckForInterruptTrampoline.
		self MoveR: TempReg R: t1.
		self CmpCq: 1 R: t1.
		jump2 := self JumpNonZero: 0.
		s31 := bytecodePC.
		s32 := s31 + s6.
		s33 := s32 + 2.
		self Jump: (self ensureFixupAt: s33).
		deadCode := true.
		jump3 := self Jump: 0.
		deadCode := false.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		s36 := bytecodePC.
		s37 := s36 + s6.
		s38 := s37 + 2.
		self Jump: (self ensureFixupAt: s38).
		deadCode := true.
		jump2 := self Jump: 0.
		deadCode := false.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		s41 := bytecodePC.
		s42 := s41 + s6.
		s43 := s42 + 2.
		self Jump: (self ensureFixupAt: s43).
		deadCode := true.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		jump2 jmpTarget: currentBlock.
		^ 0 ].
	s12 := 0.
	s10 := s12.
	extB := 0.
	numExtB := 0.
	s18 := s6 + s10.
	self ssFlushStack.
	s18 >= 0 ifTrue: [
		s21 := bytecodePC.
		s22 := s21 + s6.
		s23 := s22 + 2.
		self Jump: (self ensureFixupAt: s23).
		deadCode := true.
		^ 0 ].
	self MoveR: SPReg R: t0.
	self MoveAw: coInterpreter stackLimitAddress R: t1.
	self CmpR: t1 R: t0.
	jump2 := self JumpAboveOrEqual: 0.
	self CallRT: ceCheckForInterruptTrampoline.
	self MoveR: TempReg R: t1.
	self CmpCq: 1 R: t1.
	jump3 := self JumpNonZero: 0.
	s31 := bytecodePC.
	s32 := s31 + s6.
	s33 := s32 + 2.
	self Jump: (self ensureFixupAt: s33).
	deadCode := true.
	jump1 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s36 := bytecodePC.
	s37 := s36 + s6.
	s38 := s37 + 2.
	self Jump: (self ensureFixupAt: s38).
	deadCode := true.
	jump3 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	s41 := bytecodePC.
	s42 := s41 + s6.
	s43 := s42 + 2.
	self Jump: (self ensureFixupAt: s43).
	deadCode := true.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_LongPushTemporaryVariableBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: byte1) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_LongStoreAndPopTemporaryVariableBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssFlushUpThroughTemporaryVariable: byte1.
	self MoveR: t0 Mw: (self frameOffsetOfTemporary: byte1) r: FPReg.
	self ssPop: 1 popSpilled: true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_LongStoreTemporaryVariableBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssFlushUpThroughTemporaryVariable: byte1.
	self MoveR: t0 Mw: (self frameOffsetOfTemporary: byte1) r: FPReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PopStackBytecode [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self ssPop: 1 popSpilled: true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveAdd [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self mclassIsSmallInteger ifFalse: [ ^ UnimplementedPrimitive ].
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self TstCq: 1 R: SendNumArgsReg.
	jump1 := self JumpZero: 0.
	self AddCq:  -1 R: SendNumArgsReg.
	self AddR: ClassReg R: SendNumArgsReg.
	jump2 := self JumpOverflow: 0.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveAsCharacter [
	"AutoGenerated by Druid"

	| s16 s2 currentBlock s17 s3 |
	s2 := self methodNumArgs.
	s2 = 0 ifTrue: [
		| jump1 jump2 jump3 |
		self MoveR: ReceiverResultReg R: ClassReg.
		self TstCq: 1 R: ClassReg.
		jump1 := self JumpZero: 0.
		self ArithmeticShiftRightCq: 3 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump2 := self JumpLess: 0.
		self CmpCq: 16r3FFFFFFF R: ClassReg.
		jump3 := self JumpGreater: 0.
		self LogicalShiftLeftCq: 3 R: ClassReg.
		self AddCq: 2 R: ClassReg.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		^ 0 ].
	s16 := self methodNumArgs.
	s16 = 1 ifTrue: [
		| jump1 jump2 jump3 |
		self MoveR: Arg0Reg R: ClassReg.
		self TstCq: 1 R: ClassReg.
		jump1 := self JumpZero: 0.
		self ArithmeticShiftRightCq: 3 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump2 := self JumpLess: 0.
		self CmpCq: 16r3FFFFFFF R: ClassReg.
		jump3 := self JumpGreater: 0.
		self LogicalShiftLeftCq: 3 R: ClassReg.
		self AddCq: 2 R: ClassReg.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		^ 0 ].
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveAsFloat [
	"AutoGenerated by Druid"

	| jump5 s30 jump1 jump3 s33 currentBlock jump2 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: ClassReg.
	self MoveR: ClassReg R: SendNumArgsReg.
	self LogicalShiftRightCq: 52 R: SendNumArgsReg.
	self AndCq: 2047 R: SendNumArgsReg.
	self CmpCq: 896 R: SendNumArgsReg.
	jump1 := self JumpBelowOrEqual: 0.
	self CmpCq: 1151 R: SendNumArgsReg.
	jump2 := self JumpBelowOrEqual: 0.
	jump3 := self JumpAbove: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self AndCq: 16rFFFFFFFFFFFFF R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self CmpCq: 0 R: SendNumArgsReg.
	jump4 := self JumpZero: 0.
	jump5 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self CmpCq: 896 R: SendNumArgsReg.
	jump1 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveRd: DPFPReg0 R: SendNumArgsReg.
	self RotateLeftCq: 1 R: SendNumArgsReg.
	self CmpCq: 1 R: SendNumArgsReg.
	jump4 := self JumpBelowOrEqual: 0.
	self SubCq: 16r7000000000000000 R: SendNumArgsReg.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 4 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 4 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: ClassReg.
	self AddCq: 16 R: ClassReg.
	s30 := objectMemory getScavengeThreshold.
	self CmpCq: s30 R: ClassReg.
	jump1 := self JumpAbove: 0.
	s33 := 72057594205700130.
	self MoveCq: s33 R: ClassReg.
	self MoveR: ClassReg M64: 0 r: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: ClassReg.
	self AddCq: 16 R: ClassReg.
	self MoveR: ClassReg Aw: objectMemory freeStartAddress.
	self MoveRd: DPFPReg0 M64: 8 r: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveAt [
	"AutoGenerated by Druid"

	| jump1 s72 s54 s92 jump6 jump3 currentBlock jump8 jump5 jump2 jump7 jump4 |
	self SubCq: 24 R: SPReg.
	self MoveR: ReceiverResultReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveR: Arg0Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self TstCq: 7 R: Extra3Reg.
	jump1 := self JumpZero: 0.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self AndCq: 1 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self ArithmeticShiftRightCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 16 r: SPReg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra1Reg.
	self LogicalShiftRightCq: 24 R: Extra1Reg.
	self AndCq: 31 R: Extra1Reg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMb: 7 r: Extra3Reg R: Extra2Reg.
	self AndCq: 255 R: Extra2Reg.
	self CmpCq: 255 R: Extra2Reg.
	jump1 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: -8 r: Extra3Reg R: Extra2Reg.
	self LogicalShiftLeftCq: 8 R: Extra2Reg.
	self LogicalShiftRightCq: 8 R: Extra2Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 5 R: Extra1Reg.
	jump4 := self JumpAbove: 0.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 16 R: Extra1Reg.
	jump4 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 3 R: Extra2Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self AndCq: 7 R: ClassReg.
	self SubR: ClassReg R: Extra2Reg.
	self MoveR: Extra2Reg R: ClassReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 12 R: Extra1Reg.
	jump4 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 2 R: Extra2Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self AndCq: 3 R: ClassReg.
	self SubR: ClassReg R: Extra2Reg.
	self MoveR: Extra2Reg R: ClassReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 10 R: Extra1Reg.
	jump4 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 1 R: Extra2Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self AndCq: 1 R: ClassReg.
	self SubR: ClassReg R: Extra2Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra1Reg.
	jump4 := self JumpNonZero: 0.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	s54 := 0.
	self MoveCq: s54 R: Extra2Reg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra1Reg.
	jump8 := self JumpBelow: 0.
	self MoveR: Extra2Reg R: ClassReg.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self CmpCq: 2 R: Extra1Reg.
	jump8 := self JumpNonZero: 0.
	self MoveR: Extra2Reg R: ClassReg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	s72 := 0.
	self MoveCq: s72 R: Extra2Reg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self CmpCq: 2 R: Extra1Reg.
	jump8 := self JumpAboveOrEqual: 0.
	self MoveR: Extra2Reg R: ClassReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: ClassReg.
	self AndCq: 16r3FFFFF R: ClassReg.
	self CmpCq: 31 R: ClassReg.
	jump8 := self JumpAbove: 0.
	self CmpCq: 31 R: ClassReg.
	jump7 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 8 R: ClassReg.
	jump7 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: ClassReg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self MoveR: ClassReg R: SendNumArgsReg.
	self LogicalShiftRightCq: 10 R: SendNumArgsReg.
	s92 := objectMemory hiddenRootsObject.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: s92 R: SendNumArgsReg.
	self MoveM64: 8 r: SendNumArgsReg R: SendNumArgsReg.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	self CmpR: Extra0Reg R: SendNumArgsReg.
	jump7 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self AndCq: 1023 R: ClassReg.
	self LogicalShiftLeftCq: 3 R: ClassReg.
	self AddR: ClassReg R: SendNumArgsReg.
	self MoveM64: 8 r: SendNumArgsReg R: Extra0Reg.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveM64: 24 r: ClassReg R: Extra0Reg.
	self ArithmeticShiftRightCq: 3 R: Extra0Reg.
	self AndCq: 16rFFFF R: Extra0Reg.
	self MoveR: Extra2Reg R: ClassReg.
	self MoveR: Extra0Reg R: Extra2Reg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 3 R: Extra1Reg.
	jump6 := self JumpNonZero: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self AndCq: 16r3FFFFF R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 16 r: SPReg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self CmpCq: 36 R: Extra3Reg.
	jump5 := self JumpNonZero: 0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self SubR: Extra2Reg R: ClassReg.
	self CmpCq: 24 R: Extra1Reg.
	jump5 := self JumpBelow: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 1 R: Extra3Reg.
	jump5 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpR: ClassReg R: Extra3Reg.
	jump3 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AddR: Extra2Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self CmpCq: 5 R: Extra1Reg.
	jump2 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 8 r: Extra3Reg R: Extra0Reg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 16 R: Extra1Reg.
	jump2 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveMw: 0 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AddCq:  -1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveMb: 8 r: Extra3Reg R: Extra0Reg.
	self AndCq: 255 R: Extra0Reg.
	self LogicalShiftLeftCq: 3 R: Extra0Reg.
	self AddCq: 1 R: Extra0Reg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 12 R: Extra1Reg.
	jump2 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM16: 8 r: Extra3Reg R: Extra0Reg.
	self AndCq: 16rFFFF R: Extra0Reg.
	self LogicalShiftLeftCq: 3 R: Extra0Reg.
	self AddCq: 1 R: Extra0Reg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra1Reg.
	jump2 := self JumpNonZero: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 8 r: Extra3Reg R: Extra0Reg.
	self CmpCq: 16rFFFFFFFFFFFFFFF R: Extra0Reg.
	jump7 := self JumpAbove: 0.
	self LogicalShiftLeftCq: 3 R: Extra0Reg.
	self AddCq: 1 R: Extra0Reg.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ReceiverResultReg.
	self AddCq: 24 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self AddCq: 24 R: SPReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveAtPut [
	"AutoGenerated by Druid"

	| s6 s140 jump5 s169 jump10 s145 jump3 s119 s167 jump15 s92 s14 s143 jump1 currentBlock s220 jump8 s67 s132 s187 jump6 jumpNext jump11 jump13 jump4 s23 s191 jumpTrue jump16 s135 jump2 jump9 jump14 jump7 s74 jump12 |
	self SubCq: 24 R: SPReg.
	self MoveR: ReceiverResultReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 16 r: SPReg.
	self MoveR: Arg0Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveR: Arg1Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self TstCq: 7 R: Extra3Reg.
	jump1 := self JumpZero: 0.
	s6 := 1.
	self MoveCq: s6 R: SendNumArgsReg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra1Reg.
	self AndCq: 1 R: Extra1Reg.
	self CmpCq: 0 R: Extra1Reg.
	jump1 := self JumpNonZero: 0.
	self CmpCq: 0 R: Extra1Reg.
	jump3 := self JumpNonZero: 0.
	s14 := 1.
	self MoveCq: s14 R: SendNumArgsReg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self ArithmeticShiftRightCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: Extra1Reg.
	self MoveR: Extra1Reg R: Extra2Reg.
	self AndCq: 16r3FFFFF R: Extra2Reg.
	self CmpCq: 36 R: Extra2Reg.
	jump3 := self JumpNonZero: 0.
	s23 := 1.
	self MoveCq: s23 R: SendNumArgsReg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self LogicalShiftRightCq: 24 R: Extra1Reg.
	self AndCq: 31 R: Extra1Reg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveMb: 7 r: Extra3Reg R: Extra2Reg.
	self AndCq: 255 R: Extra2Reg.
	self CmpCq: 255 R: Extra2Reg.
	jump3 := self JumpNonZero: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveM64: -8 r: Extra3Reg R: Extra2Reg.
	self LogicalShiftLeftCq: 8 R: Extra2Reg.
	self LogicalShiftRightCq: 8 R: Extra2Reg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 5 R: Extra1Reg.
	jump5 := self JumpAbove: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 16 R: Extra1Reg.
	jump5 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 3 R: Extra2Reg.
	self MoveR: Extra1Reg R: SendNumArgsReg.
	self AndCq: 7 R: SendNumArgsReg.
	self SubR: SendNumArgsReg R: Extra2Reg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 12 R: Extra1Reg.
	jump5 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 2 R: Extra2Reg.
	self MoveR: Extra1Reg R: SendNumArgsReg.
	self AndCq: 3 R: SendNumArgsReg.
	self SubR: SendNumArgsReg R: Extra2Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 10 R: Extra1Reg.
	jump5 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 1 R: Extra2Reg.
	self MoveR: Extra1Reg R: SendNumArgsReg.
	self AndCq: 1 R: SendNumArgsReg.
	self SubR: SendNumArgsReg R: Extra2Reg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra1Reg.
	jump5 := self JumpNonZero: 0.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	s67 := 0.
	self MoveCq: s67 R: Extra2Reg.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra1Reg.
	jump9 := self JumpBelow: 0.
	self CmpCq: 9 R: Extra1Reg.
	jump8 := self JumpAboveOrEqual: 0.
	jump7 := self JumpBelow: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 2 R: Extra1Reg.
	jump9 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s74 := 0.
	self MoveCq: s74 R: SendNumArgsReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 2 R: Extra1Reg.
	jump9 := self JumpAboveOrEqual: 0.
	self MoveR: Extra2Reg R: SendNumArgsReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: SendNumArgsReg.
	self AndCq: 16r3FFFFF R: SendNumArgsReg.
	self CmpCq: 31 R: SendNumArgsReg.
	jump9 := self JumpAbove: 0.
	self CmpCq: 31 R: SendNumArgsReg.
	jump6 := self JumpNonZero: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: SendNumArgsReg.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 8 R: SendNumArgsReg.
	jump6 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: SendNumArgsReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 10 R: Extra0Reg.
	s92 := objectMemory hiddenRootsObject.
	self LogicalShiftLeftCq: 3 R: Extra0Reg.
	self AddCq: s92 R: Extra0Reg.
	self MoveM64: 8 r: Extra0Reg R: Extra0Reg.
	self genMoveConstant: objectMemory nilObject R: ClassReg.
	self CmpR: ClassReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: ClassReg.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self AndCq: 1023 R: SendNumArgsReg.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddR: SendNumArgsReg R: Extra0Reg.
	self MoveM64: 8 r: Extra0Reg R: ClassReg.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveR: ClassReg R: SendNumArgsReg.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 24 r: SendNumArgsReg R: ClassReg.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self AndCq: 16rFFFF R: ClassReg.
	self MoveR: ClassReg R: SendNumArgsReg.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self SubR: SendNumArgsReg R: Extra2Reg.
	self CmpCq: 24 R: Extra1Reg.
	jump7 := self JumpBelow: 0.
	s119 := 1.
	self MoveCq: s119 R: SendNumArgsReg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self CmpCq: 1 R: Extra3Reg.
	jump7 := self JumpBelow: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self CmpR: Extra2Reg R: Extra3Reg.
	jump5 := self JumpAbove: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self AddR: SendNumArgsReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self CmpCq: 5 R: Extra1Reg.
	jump3 := self JumpAbove: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	self AndCq: 7 R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump9 := self JumpNonZero: 0.
	s132 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	self AndCq: s132 R: ClassReg.
	s135 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s135 R: ClassReg.
	jump6 := self JumpNonZero: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	self AndCq: 7 R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump10 := self JumpNonZero: 0.
	s140 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	self AndCq: s140 R: ClassReg.
	s143 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s143 R: ClassReg.
	jump11 := self JumpNonZero: 0.
	s145 := objectMemory getMemoryMap getNewSpaceStart.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	self CmpCq: s145 R: ClassReg.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: ClassReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: ClassReg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: ClassReg.
	jump12 := self JumpNonZero: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: ClassReg.
	self LogicalShiftRightCq: 29 R: ClassReg.
	self AndCq: 1 R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump13 := self JumpNonZero: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	jump14 := self Jump: 0.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump10 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	jump13 jmpTarget: currentBlock.
	jump14 jmpTarget: currentBlock.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: ClassReg.
	self LogicalShiftRightCq: 29 R: ClassReg.
	self AndCq: 1 R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump14 := self JumpNonZero: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self TstCq: 7 R: Extra3Reg.
	jump13 := self JumpNonZero: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self CmpCq: 16r20000000000 R: Extra3Reg.
	jump12 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 16r20000000000 R: Extra3Reg.
	jump10 := self JumpAboveOrEqual: 0.
	self genMoveConstant: objectMemory nilObject R: ClassReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpR: ClassReg R: Extra3Reg.
	jump6 := self JumpBelow: 0.
	s167 := objectMemory trueObject.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: s167 R: Extra3Reg.
	jump9 := self JumpBelowOrEqual: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	s169 := objectMemory getMemoryMap getNewSpaceStart.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: s169 R: Extra3Reg.
	jump6 := self JumpBelow: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump14 jmpTarget: currentBlock.
	jump13 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	jump10 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveMw: 0 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 16 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveMw: 16 r: SPReg R: Extra4Reg.
	self MoveR: Extra3Reg M64: 8 r: Extra4Reg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 16 R: Extra1Reg.
	jump3 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self TstCq: 1 R: Extra3Reg.
	jump9 := self JumpZero: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump10 := self JumpBelow: 0.
	self CmpCq: 255 R: ClassReg.
	jump12 := self JumpAbove: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 16 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self AddCq:  -1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: ClassReg Mb: 8 r: Extra3Reg.
	jump13 := self Jump: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	s187 := 1.
	self MoveCq: s187 R: SendNumArgsReg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	jump12 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	s191 := 1.
	self MoveCq: s191 R: SendNumArgsReg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 12 R: Extra1Reg.
	jump3 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self TstCq: 1 R: Extra3Reg.
	jump10 := self JumpZero: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump14 := self JumpBelow: 0.
	self CmpCq: 16rFFFF R: ClassReg.
	jump11 := self JumpAbove: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveMw: 0 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 16 r: SPReg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra2Reg.
	self AddCq: 8 R: Extra2Reg.
	self MoveR: Extra2Reg R: Extra1Reg.
	self AndCq: 2 R: Extra1Reg.
	self CmpCq: 0 R: Extra1Reg.
	jump15 := self JumpNonZero: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveM32: 8 r: Extra3Reg R: Extra1Reg.
	self AndCq: 16rFFFFFFFF R: Extra1Reg.
	self AndCq: 16rFFFF0000 R: Extra1Reg.
	self OrR: ClassReg R: Extra1Reg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra1Reg M32: 8 r: Extra3Reg.
	jump16 := self Jump: 0.
	currentBlock := self Label.
	jump15 jmpTarget: currentBlock.
	self MoveM32: -2 r: Extra2Reg R: Extra1Reg.
	self AndCq: 16rFFFFFFFF R: Extra1Reg.
	self AndCq: 16rFFFF R: Extra1Reg.
	self LogicalShiftLeftCq: 16 R: ClassReg.
	self OrR: ClassReg R: Extra1Reg.
	self MoveR: Extra1Reg M32: -2 r: Extra2Reg.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	jump13 jmpTarget: currentBlock.
	jump16 jmpTarget: currentBlock.
	s220 := 0.
	self MoveCq: s220 R: SendNumArgsReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	self MoveR: ClassReg R: ReceiverResultReg.
	self CmpCq: 0 R: SendNumArgsReg.
	jump9 := self JumpNonZero: 0.
	self AddCq: 24 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump14 jmpTarget: currentBlock.
	jump11 jmpTarget: currentBlock.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra1Reg.
	self MoveR: Extra1Reg R: ReceiverResultReg.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra1Reg.
	jump3 := self JumpZero: 0.
	jump11 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	jump10 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self AddCq: 24 R: SPReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveBitAnd [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndR: ClassReg R: Extra0Reg.
	self TstCq: 1 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self AndR: ClassReg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveBitOr [
	"AutoGenerated by Druid"

	| jump1 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndR: ClassReg R: Extra0Reg.
	self TstCq: 1 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self OrR: ClassReg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveBitShift [
	"AutoGenerated by Druid"

	| jump1 s43 jump9 jump6 jump3 s42 s18 currentBlock jump8 jump5 s64 jump2 s55 jump7 jump4 |
	self mclassIsSmallInteger ifFalse: [ ^ UnimplementedPrimitive ].
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self TstCq: 1 R: SendNumArgsReg.
	jump1 := self JumpZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self CmpCq: 0 R: SendNumArgsReg.
	jump2 := self JumpLess: 0.
	self CmpCq: 61 R: SendNumArgsReg.
	jump3 := self JumpGreater: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftR: SendNumArgsReg R: Extra0Reg.
	self MoveR: Extra0Reg R: Extra1Reg.
	self ArithmeticShiftRightR: SendNumArgsReg R: Extra1Reg.
	self CmpR: Extra1Reg R: ClassReg.
	jump4 := self JumpNonZero: 0.
	self MoveR: Extra0Reg R: Extra1Reg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq:  -61 R: SendNumArgsReg.
	jump2 := self JumpLess: 0.
	s18 := 0.
	self MoveCq: s18 R: Extra1Reg.
	self SubR: SendNumArgsReg R: Extra1Reg.
	self ArithmeticShiftRightR: Extra1Reg R: ClassReg.
	self MoveR: ClassReg R: Extra1Reg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveR: Extra1Reg R: SendNumArgsReg.
	self LogicalShiftRightCq: 60 R: SendNumArgsReg.
	self AddCq: 1 R: SendNumArgsReg.
	self AndCq: 15 R: SendNumArgsReg.
	self CmpCq: 1 R: SendNumArgsReg.
	jump5 := self JumpAbove: 0.
	self MoveR: Extra1Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 1 R: SendNumArgsReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 0 R: Extra1Reg.
	jump5 := self JumpGreaterOrEqual: 0.
	self CmpCq:  -1152921504606846976 R: Extra1Reg.
	jump7 := self JumpLess: 0.
	self MoveR: Extra1Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 1 R: SendNumArgsReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	s42 := 32.
	s43 := 0.
	self MoveCq: s43 R: SendNumArgsReg.
	self SubR: Extra1Reg R: SendNumArgsReg.
	self MoveCq: s42 R: ClassReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 16rFFFFFFFFFFFFFFF R: Extra1Reg.
	jump5 := self JumpGreater: 0.
	self MoveR: Extra1Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 1 R: SendNumArgsReg.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	s55 := 33.
	self MoveCq: s55 R: ClassReg.
	self MoveR: Extra1Reg R: SendNumArgsReg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: Extra1Reg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	s64 := objectMemory getScavengeThreshold.
	self CmpCq: s64 R: Extra0Reg.
	jump7 := self JumpAbove: 0.
	self AddCq: 16r100000010000000 R: ClassReg.
	self MoveR: ClassReg M64: 0 r: Extra1Reg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	self MoveR: Extra0Reg Aw: objectMemory freeStartAddress.
	self AndCq: 16rFFFFFFFFFFFFFFFF R: SendNumArgsReg.
	self MoveR: SendNumArgsReg M64: 8 r: Extra1Reg.
	self MoveR: Extra1Reg R: SendNumArgsReg.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveBitXor [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self TstCq: 1 R: SendNumArgsReg.
	jump1 := self JumpZero: 0.
	self TstCq: 1 R: ClassReg.
	jump2 := self JumpZero: 0.
	self XorR: ClassReg R: SendNumArgsReg.
	self AddCq: 1 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self CmpCq: 0 R: SendNumArgsReg.
	jump2 := self JumpGreaterOrEqual: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveClass [
	"AutoGenerated by Druid"

	| s25 s71 s40 s2 currentBlock s41 s3 |
	s2 := self methodNumArgs.
	s2 = 0 ifTrue: [
		| jump1 jump2 |
		self MoveR: ReceiverResultReg R: ClassReg.
		self MoveR: ClassReg R: SendNumArgsReg.
		self AndCq: 7 R: SendNumArgsReg.
		self CmpCq: 0 R: SendNumArgsReg.
		jump1 := self JumpZero: 0.
		self MoveAw: objectMemory hiddenRootsObject + 8 R: ClassReg.
		self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
		self AddR: SendNumArgsReg R: ClassReg.
		self MoveM64: 8 r: ClassReg R: ClassReg.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self MoveM64: 0 r: ClassReg R: ClassReg.
		self AndCq: 16r3FFFFF R: ClassReg.
		self CmpCq: 31 R: ClassReg.
		jump1 := self JumpAbove: 0.
		self CmpCq: 31 R: ClassReg.
		jump2 := self JumpNonZero: 0.
		self genPrimReturn.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		self CmpCq: 8 R: ClassReg.
		jump2 := self JumpNonZero: 0.
		self genMoveConstant: objectMemory nilObject R: ClassReg.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		jump2 jmpTarget: currentBlock.
		self MoveR: ClassReg R: SendNumArgsReg.
		self LogicalShiftRightCq: 10 R: SendNumArgsReg.
		s25 := objectMemory hiddenRootsObject.
		self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
		self AddCq: s25 R: SendNumArgsReg.
		self MoveM64: 8 r: SendNumArgsReg R: SendNumArgsReg.
		self genMoveConstant: objectMemory nilObject R: Extra0Reg.
		self CmpR: Extra0Reg R: SendNumArgsReg.
		jump2 := self JumpNonZero: 0.
		self genMoveConstant: objectMemory nilObject R: Extra0Reg.
		self MoveR: Extra0Reg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		self AndCq: 1023 R: ClassReg.
		self LogicalShiftLeftCq: 3 R: ClassReg.
		self AddR: ClassReg R: SendNumArgsReg.
		self MoveM64: 8 r: SendNumArgsReg R: Extra0Reg.
		self MoveR: Extra0Reg R: ReceiverResultReg.
		self genPrimReturn.
		^ 0 ].
	s40 := self methodNumArgs.
	s40 = 1 ifTrue: [
		| jump2 jump1 |
		self MoveR: Arg0Reg R: Extra0Reg.
		self MoveR: Extra0Reg R: SendNumArgsReg.
		self AndCq: 7 R: SendNumArgsReg.
		self CmpCq: 0 R: SendNumArgsReg.
		jump2 := self JumpNonZero: 0.
		self MoveM64: 0 r: Extra0Reg R: SendNumArgsReg.
		self AndCq: 16r3FFFF7 R: SendNumArgsReg.
		self CmpCq: 0 R: SendNumArgsReg.
		jump1 := self JumpNonZero: 0.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		jump1 jmpTarget: currentBlock.
		self MoveR: Extra0Reg R: SendNumArgsReg.
		self AndCq: 7 R: SendNumArgsReg.
		self CmpCq: 0 R: SendNumArgsReg.
		jump1 := self JumpZero: 0.
		self MoveAw: objectMemory hiddenRootsObject + 8 R: Extra0Reg.
		self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
		self AddR: SendNumArgsReg R: Extra0Reg.
		self MoveM64: 8 r: Extra0Reg R: Extra0Reg.
		self MoveR: Extra0Reg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self MoveM64: 0 r: Extra0Reg R: SendNumArgsReg.
		self AndCq: 16r3FFFFF R: SendNumArgsReg.
		self CmpCq: 31 R: SendNumArgsReg.
		jump1 := self JumpAbove: 0.
		self CmpCq: 31 R: SendNumArgsReg.
		jump2 := self JumpNonZero: 0.
		self MoveR: Extra0Reg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		self CmpCq: 8 R: SendNumArgsReg.
		jump2 := self JumpNonZero: 0.
		self genMoveConstant: objectMemory nilObject R: SendNumArgsReg.
		self MoveR: SendNumArgsReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		jump2 jmpTarget: currentBlock.
		self MoveR: SendNumArgsReg R: Extra0Reg.
		self LogicalShiftRightCq: 10 R: Extra0Reg.
		s71 := objectMemory hiddenRootsObject.
		self LogicalShiftLeftCq: 3 R: Extra0Reg.
		self AddCq: s71 R: Extra0Reg.
		self MoveM64: 8 r: Extra0Reg R: Extra0Reg.
		self genMoveConstant: objectMemory nilObject R: ClassReg.
		self CmpR: ClassReg R: Extra0Reg.
		jump2 := self JumpNonZero: 0.
		self genMoveConstant: objectMemory nilObject R: ClassReg.
		jump1 := self Jump: 0.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		self AndCq: 1023 R: SendNumArgsReg.
		self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
		self AddR: SendNumArgsReg R: Extra0Reg.
		self MoveM64: 8 r: Extra0Reg R: ClassReg.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		^ 0 ].
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveDiv [
	"AutoGenerated by Druid"

	| jump1 s31 s16 s39 s77 jump3 currentBlock jump5 jump2 s44 s70 s23 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndR: SendNumArgsReg R: Extra0Reg.
	self TstCq: 1 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self ArithmeticShiftRightCq: 3 R: Extra0Reg.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self CmpCq: 0 R: SendNumArgsReg.
	jump2 := self JumpZero: 0.
	self CmpCq: 0 R: Extra0Reg.
	jump3 := self JumpLessOrEqual: 0.
	self CmpCq: 0 R: SendNumArgsReg.
	jump4 := self JumpLessOrEqual: 0.
	self
		DivR: SendNumArgsReg
		R: Extra0Reg
		Quo: Extra0Reg
		Rem: SendNumArgsReg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	s16 := 0.
	self MoveCq: s16 R: Extra1Reg.
	self SubR: SendNumArgsReg R: Extra1Reg.
	self MoveR: Extra1Reg R: SendNumArgsReg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self AddCq:  -1 R: SendNumArgsReg.
	self
		DivR: Extra1Reg
		R: SendNumArgsReg
		Quo: Extra1Reg
		Rem: SendNumArgsReg.
	s23 := 0.
	self MoveCq: s23 R: SendNumArgsReg.
	self SubR: Extra1Reg R: SendNumArgsReg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s31 := 0.
	self MoveCq: s31 R: Extra1Reg.
	self SubR: Extra0Reg R: Extra1Reg.
	self CmpCq: 0 R: SendNumArgsReg.
	jump3 := self JumpLessOrEqual: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AddR: Extra1Reg R: Extra0Reg.
	self AddCq:  -1 R: Extra0Reg.
	self
		DivR: SendNumArgsReg
		R: Extra0Reg
		Quo: Extra0Reg
		Rem: Extra1Reg.
	s39 := 0.
	self MoveCq: s39 R: Extra1Reg.
	self SubR: Extra0Reg R: Extra1Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s44 := 0.
	self MoveCq: s44 R: Extra0Reg.
	self SubR: SendNumArgsReg R: Extra0Reg.
	self
		DivR: Extra0Reg
		R: Extra1Reg
		Quo: Extra0Reg
		Rem: Extra1Reg.
	self MoveR: Extra0Reg R: Extra1Reg.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra1Reg R: SendNumArgsReg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra1Reg.
	self LogicalShiftRightCq: 60 R: Extra1Reg.
	self AddCq: 1 R: Extra1Reg.
	self AndCq: 15 R: Extra1Reg.
	self CmpCq: 1 R: Extra1Reg.
	jump5 := self JumpAbove: 0.
	self MoveR: SendNumArgsReg R: Extra1Reg.
	self LogicalShiftRightCq: 60 R: Extra1Reg.
	self AddCq: 1 R: Extra1Reg.
	self AndCq: 15 R: Extra1Reg.
	self CmpCq: 1 R: Extra1Reg.
	jump4 := self JumpAbove: 0.
	self MoveR: SendNumArgsReg R: Extra1Reg.
	self LogicalShiftLeftCq: 3 R: Extra1Reg.
	self AddCq: 1 R: Extra1Reg.
	s70 := 0.
	self MoveCq: s70 R: SendNumArgsReg.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: ClassReg R: SendNumArgsReg.
	s77 := 1.
	self MoveR: SendNumArgsReg R: Extra1Reg.
	self MoveCq: s77 R: SendNumArgsReg.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveR: Extra1Reg R: ReceiverResultReg.
	self CmpCq: 0 R: SendNumArgsReg.
	jump3 := self JumpNonZero: 0.
	self genPrimReturn.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveDivide [
	"AutoGenerated by Druid"

	| jump5 jump3 jump1 currentBlock jump4 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self TstCq: 1 R: ClassReg.
	jump1 := self JumpZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self TstCq: 1 R: SendNumArgsReg.
	jump2 := self JumpZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self CmpCq: 0 R: SendNumArgsReg.
	jump3 := self JumpZero: 0.
	self
		DivR: SendNumArgsReg
		R: ClassReg
		Quo: Extra0Reg
		Rem: Extra1Reg.
	self CmpCq: 0 R: Extra1Reg.
	jump4 := self JumpNonZero: 0.
	self
		DivR: SendNumArgsReg
		R: ClassReg
		Quo: Extra0Reg
		Rem: Extra1Reg.
	self MoveR: Extra0Reg R: Extra1Reg.
	self LogicalShiftRightCq: 60 R: Extra1Reg.
	self AddCq: 1 R: Extra1Reg.
	self AndCq: 15 R: Extra1Reg.
	self CmpCq: 1 R: Extra1Reg.
	jump5 := self JumpAbove: 0.
	self MoveR: Extra0Reg R: Extra1Reg.
	self LogicalShiftLeftCq: 3 R: Extra1Reg.
	self AddCq: 1 R: Extra1Reg.
	self MoveR: Extra1Reg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveEqual [
	"AutoGenerated by Druid"

	| s11 s8 jump1 currentBlock jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndR: SendNumArgsReg R: Extra0Reg.
	self TstCq: 1 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpR: SendNumArgsReg R: ClassReg.
	jump2 := self JumpNonZero: 0.
	s8 := objectMemory trueObject.
	self MoveCq: s8 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	s11 := objectMemory falseObject.
	self MoveCq: s11 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveFloatAdd [
	"AutoGenerated by Druid"

	| jump1 s123 jumpNext s98 s126 jump9 jump6 jump3 jump10 currentBlock s91 jump5 jump2 jump8 jumpTrue jump11 jump7 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self AddRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: Extra0Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftRightCq: 52 R: SendNumArgsReg.
	self AndCq: 2047 R: SendNumArgsReg.
	self CmpCq: 896 R: SendNumArgsReg.
	jump8 := self JumpBelowOrEqual: 0.
	self CmpCq: 1151 R: SendNumArgsReg.
	jump7 := self JumpBelowOrEqual: 0.
	jump9 := self JumpAbove: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self AndCq: 16rFFFFFFFFFFFFF R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump8 := self JumpNonZero: 0.
	s91 := 0.
	self CmpCq: s91 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: SendNumArgsReg.
	jump10 := self JumpZero: 0.
	jump11 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s98 := 896.
	self CmpCq: s98 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: SendNumArgsReg.
	jump8 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveRd: DPFPReg0 R: SendNumArgsReg.
	self RotateLeftCq: 1 R: SendNumArgsReg.
	self CmpCq: 1 R: SendNumArgsReg.
	jump7 := self JumpBelowOrEqual: 0.
	self SubCq: 16r7000000000000000 R: SendNumArgsReg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 4 R: SendNumArgsReg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	s123 := objectMemory getScavengeThreshold.
	self CmpCq: s123 R: Extra0Reg.
	jump9 := self JumpAbove: 0.
	s126 := 72057594205700130.
	self MoveCq: s126 R: Extra0Reg.
	self MoveR: Extra0Reg M64: 0 r: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	self MoveR: Extra0Reg Aw: objectMemory freeStartAddress.
	self MoveRd: DPFPReg0 M64: 8 r: SendNumArgsReg.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveFloatEqual [
	"AutoGenerated by Druid"

	| jump1 s86 s83 jump6 jump3 currentBlock jump8 jump5 jump2 jump7 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jump8 := self JumpFPNotEqual: 0.
	s83 := objectMemory trueObject.
	self MoveCq: s83 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s86 := objectMemory falseObject.
	self MoveCq: s86 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveFloatGreaterOrEqual [
	"AutoGenerated by Druid"

	| jump1 s86 s83 jump6 jump3 currentBlock jump8 jump5 jump2 jump7 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jump8 := self JumpFPLess: 0.
	s83 := objectMemory trueObject.
	self MoveCq: s83 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s86 := objectMemory falseObject.
	self MoveCq: s86 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveFloatGreaterThan [
	"AutoGenerated by Druid"

	| jump1 s86 s83 jump6 jump3 currentBlock jump8 jump5 jump2 jump7 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jump8 := self JumpFPLessOrEqual: 0.
	s83 := objectMemory trueObject.
	self MoveCq: s83 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s86 := objectMemory falseObject.
	self MoveCq: s86 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveFloatLessOrEqual [
	"AutoGenerated by Druid"

	| jump1 s86 s83 jump6 jump3 currentBlock jump8 jump5 jump2 jump7 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jump8 := self JumpFPGreater: 0.
	s83 := objectMemory trueObject.
	self MoveCq: s83 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s86 := objectMemory falseObject.
	self MoveCq: s86 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveFloatLessThan [
	"AutoGenerated by Druid"

	| jump1 s86 s83 jump6 jump3 currentBlock jump8 jump5 jump2 jump7 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jump8 := self JumpFPGreaterOrEqual: 0.
	s83 := objectMemory trueObject.
	self MoveCq: s83 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s86 := objectMemory falseObject.
	self MoveCq: s86 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveFloatMultiply [
	"AutoGenerated by Druid"

	| jump1 s123 jumpNext s98 s126 jump9 jump6 jump3 jump10 currentBlock s91 jump5 jump2 jump8 jumpTrue jump11 jump7 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self MulRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: Extra0Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftRightCq: 52 R: SendNumArgsReg.
	self AndCq: 2047 R: SendNumArgsReg.
	self CmpCq: 896 R: SendNumArgsReg.
	jump8 := self JumpBelowOrEqual: 0.
	self CmpCq: 1151 R: SendNumArgsReg.
	jump7 := self JumpBelowOrEqual: 0.
	jump9 := self JumpAbove: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self AndCq: 16rFFFFFFFFFFFFF R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump8 := self JumpNonZero: 0.
	s91 := 0.
	self CmpCq: s91 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: SendNumArgsReg.
	jump10 := self JumpZero: 0.
	jump11 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s98 := 896.
	self CmpCq: s98 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: SendNumArgsReg.
	jump8 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveRd: DPFPReg0 R: SendNumArgsReg.
	self RotateLeftCq: 1 R: SendNumArgsReg.
	self CmpCq: 1 R: SendNumArgsReg.
	jump7 := self JumpBelowOrEqual: 0.
	self SubCq: 16r7000000000000000 R: SendNumArgsReg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 4 R: SendNumArgsReg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	s123 := objectMemory getScavengeThreshold.
	self CmpCq: s123 R: Extra0Reg.
	jump9 := self JumpAbove: 0.
	s126 := 72057594205700130.
	self MoveCq: s126 R: Extra0Reg.
	self MoveR: Extra0Reg M64: 0 r: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	self MoveR: Extra0Reg Aw: objectMemory freeStartAddress.
	self MoveRd: DPFPReg0 M64: 8 r: SendNumArgsReg.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveFloatNotEqual [
	"AutoGenerated by Druid"

	| jump1 s86 s83 jump6 jump3 currentBlock jump8 jump5 jump2 jump7 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jump8 := self JumpFPNotEqual: 0.
	s83 := objectMemory falseObject.
	self MoveCq: s83 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s86 := objectMemory trueObject.
	self MoveCq: s86 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveFloatSubtract [
	"AutoGenerated by Druid"

	| jump1 s123 jumpNext s98 s126 jump9 jump6 jump3 jump10 currentBlock s91 jump5 jump2 jump8 jumpTrue jump11 jump7 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self SubRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: Extra0Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftRightCq: 52 R: SendNumArgsReg.
	self AndCq: 2047 R: SendNumArgsReg.
	self CmpCq: 896 R: SendNumArgsReg.
	jump8 := self JumpBelowOrEqual: 0.
	self CmpCq: 1151 R: SendNumArgsReg.
	jump7 := self JumpBelowOrEqual: 0.
	jump9 := self JumpAbove: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self AndCq: 16rFFFFFFFFFFFFF R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump8 := self JumpNonZero: 0.
	s91 := 0.
	self CmpCq: s91 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: SendNumArgsReg.
	jump10 := self JumpZero: 0.
	jump11 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s98 := 896.
	self CmpCq: s98 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: SendNumArgsReg.
	jump8 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveRd: DPFPReg0 R: SendNumArgsReg.
	self RotateLeftCq: 1 R: SendNumArgsReg.
	self CmpCq: 1 R: SendNumArgsReg.
	jump7 := self JumpBelowOrEqual: 0.
	self SubCq: 16r7000000000000000 R: SendNumArgsReg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 4 R: SendNumArgsReg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	s123 := objectMemory getScavengeThreshold.
	self CmpCq: s123 R: Extra0Reg.
	jump9 := self JumpAbove: 0.
	s126 := 72057594205700130.
	self MoveCq: s126 R: Extra0Reg.
	self MoveR: Extra0Reg M64: 0 r: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	self MoveR: Extra0Reg Aw: objectMemory freeStartAddress.
	self MoveRd: DPFPReg0 M64: 8 r: SendNumArgsReg.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveFullClosureValue [
	"AutoGenerated by Druid"

	| s27 s51 s26 currentBlock s2 s52 s3 |
	s2 := self methodNumArgs.
	s2 = 0 ifTrue: [
		| jump1 jump2 jump3 jump4 |
		self MoveR: ReceiverResultReg R: ClassReg.
		self MoveM64: 24 r: ClassReg R: SendNumArgsReg.
		self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
		self CmpCq: 0 R: SendNumArgsReg.
		jump1 := self JumpNonZero: 0.
		self MoveM64: 16 r: ClassReg R: SendNumArgsReg.
		self MoveR: SendNumArgsReg R: ClassReg.
		self AndCq: 7 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump2 := self JumpNonZero: 0.
		self MoveM64: 0 r: SendNumArgsReg R: ClassReg.
		self LogicalShiftRightCq: 24 R: ClassReg.
		self AndCq: 31 R: ClassReg.
		self CmpCq: 24 R: ClassReg.
		jump3 := self JumpBelow: 0.
		self MoveM64: 8 r: SendNumArgsReg R: ClassReg.
		self AndCq: 1 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump4 := self JumpNonZero: 0.
		self MoveM64: 8 r: SendNumArgsReg R: ClassReg.
		self AddCq: self fullBlockEntryOffset R: ClassReg.
		self JumpR: ClassReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump4 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		^ 0 ].
	s26 := self methodNumArgs.
	s26 = 1 ifTrue: [
		| jump1 jump2 jump3 jump4 |
		self MoveR: ReceiverResultReg R: ClassReg.
		self MoveR: Arg0Reg R: SendNumArgsReg.
		self MoveM64: 24 r: ClassReg R: SendNumArgsReg.
		self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
		self CmpCq: 1 R: SendNumArgsReg.
		jump1 := self JumpNonZero: 0.
		self MoveM64: 16 r: ClassReg R: SendNumArgsReg.
		self MoveR: SendNumArgsReg R: ClassReg.
		self AndCq: 7 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump2 := self JumpNonZero: 0.
		self MoveM64: 0 r: SendNumArgsReg R: ClassReg.
		self LogicalShiftRightCq: 24 R: ClassReg.
		self AndCq: 31 R: ClassReg.
		self CmpCq: 24 R: ClassReg.
		jump3 := self JumpBelow: 0.
		self MoveM64: 8 r: SendNumArgsReg R: ClassReg.
		self AndCq: 1 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump4 := self JumpNonZero: 0.
		self MoveM64: 8 r: SendNumArgsReg R: ClassReg.
		self AddCq: self fullBlockEntryOffset R: ClassReg.
		self JumpR: ClassReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump4 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		^ 0 ].
	s51 := self methodNumArgs.
	s51 = 2 ifTrue: [
		| jump1 jump2 jump3 jump4 |
		self MoveR: ReceiverResultReg R: ClassReg.
		self MoveR: Arg0Reg R: SendNumArgsReg.
		self MoveR: Arg1Reg R: SendNumArgsReg.
		self MoveM64: 24 r: ClassReg R: SendNumArgsReg.
		self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
		self CmpCq: 2 R: SendNumArgsReg.
		jump1 := self JumpNonZero: 0.
		self MoveM64: 16 r: ClassReg R: SendNumArgsReg.
		self MoveR: SendNumArgsReg R: ClassReg.
		self AndCq: 7 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump2 := self JumpNonZero: 0.
		self MoveM64: 0 r: SendNumArgsReg R: ClassReg.
		self LogicalShiftRightCq: 24 R: ClassReg.
		self AndCq: 31 R: ClassReg.
		self CmpCq: 24 R: ClassReg.
		jump3 := self JumpBelow: 0.
		self MoveM64: 8 r: SendNumArgsReg R: ClassReg.
		self AndCq: 1 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump4 := self JumpNonZero: 0.
		self MoveM64: 8 r: SendNumArgsReg R: ClassReg.
		self AddCq: self fullBlockEntryOffset R: ClassReg.
		self JumpR: ClassReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump4 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		^ 0 ].
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveFullClosureValueNoContextSwitch [
	"AutoGenerated by Druid"

	| s27 s51 s26 currentBlock s2 s52 s3 |
	s2 := self methodNumArgs.
	s2 = 0 ifTrue: [
		| jump1 jump2 jump3 jump4 |
		self MoveR: ReceiverResultReg R: ClassReg.
		self MoveM64: 24 r: ClassReg R: SendNumArgsReg.
		self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
		self CmpCq: 0 R: SendNumArgsReg.
		jump1 := self JumpNonZero: 0.
		self MoveM64: 16 r: ClassReg R: SendNumArgsReg.
		self MoveR: SendNumArgsReg R: ClassReg.
		self AndCq: 7 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump2 := self JumpNonZero: 0.
		self MoveM64: 0 r: SendNumArgsReg R: ClassReg.
		self LogicalShiftRightCq: 24 R: ClassReg.
		self AndCq: 31 R: ClassReg.
		self CmpCq: 24 R: ClassReg.
		jump3 := self JumpBelow: 0.
		self MoveM64: 8 r: SendNumArgsReg R: ClassReg.
		self AndCq: 1 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump4 := self JumpNonZero: 0.
		self MoveM64: 8 r: SendNumArgsReg R: ClassReg.
		self AddCq: self fullBlockNoContextSwitchEntryOffset R: ClassReg.
		self JumpR: ClassReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump4 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		^ 0 ].
	s26 := self methodNumArgs.
	s26 = 1 ifTrue: [
		| jump1 jump2 jump3 jump4 |
		self MoveR: ReceiverResultReg R: ClassReg.
		self MoveR: Arg0Reg R: SendNumArgsReg.
		self MoveM64: 24 r: ClassReg R: SendNumArgsReg.
		self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
		self CmpCq: 1 R: SendNumArgsReg.
		jump1 := self JumpNonZero: 0.
		self MoveM64: 16 r: ClassReg R: SendNumArgsReg.
		self MoveR: SendNumArgsReg R: ClassReg.
		self AndCq: 7 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump2 := self JumpNonZero: 0.
		self MoveM64: 0 r: SendNumArgsReg R: ClassReg.
		self LogicalShiftRightCq: 24 R: ClassReg.
		self AndCq: 31 R: ClassReg.
		self CmpCq: 24 R: ClassReg.
		jump3 := self JumpBelow: 0.
		self MoveM64: 8 r: SendNumArgsReg R: ClassReg.
		self AndCq: 1 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump4 := self JumpNonZero: 0.
		self MoveM64: 8 r: SendNumArgsReg R: ClassReg.
		self AddCq: self fullBlockNoContextSwitchEntryOffset R: ClassReg.
		self JumpR: ClassReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump4 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		^ 0 ].
	s51 := self methodNumArgs.
	s51 = 2 ifTrue: [
		| jump1 jump2 jump3 jump4 |
		self MoveR: ReceiverResultReg R: ClassReg.
		self MoveR: Arg0Reg R: SendNumArgsReg.
		self MoveR: Arg1Reg R: SendNumArgsReg.
		self MoveM64: 24 r: ClassReg R: SendNumArgsReg.
		self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
		self CmpCq: 2 R: SendNumArgsReg.
		jump1 := self JumpNonZero: 0.
		self MoveM64: 16 r: ClassReg R: SendNumArgsReg.
		self MoveR: SendNumArgsReg R: ClassReg.
		self AndCq: 7 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump2 := self JumpNonZero: 0.
		self MoveM64: 0 r: SendNumArgsReg R: ClassReg.
		self LogicalShiftRightCq: 24 R: ClassReg.
		self AndCq: 31 R: ClassReg.
		self CmpCq: 24 R: ClassReg.
		jump3 := self JumpBelow: 0.
		self MoveM64: 8 r: SendNumArgsReg R: ClassReg.
		self AndCq: 1 R: ClassReg.
		self CmpCq: 0 R: ClassReg.
		jump4 := self JumpNonZero: 0.
		self MoveM64: 8 r: SendNumArgsReg R: ClassReg.
		self AddCq: self fullBlockNoContextSwitchEntryOffset R: ClassReg.
		self JumpR: ClassReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump4 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		^ 0 ].
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveGreaterOrEqual [
	"AutoGenerated by Druid"

	| s11 s8 jump1 currentBlock jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndR: SendNumArgsReg R: Extra0Reg.
	self TstCq: 1 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpR: SendNumArgsReg R: ClassReg.
	jump2 := self JumpLess: 0.
	s8 := objectMemory trueObject.
	self MoveCq: s8 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	s11 := objectMemory falseObject.
	self MoveCq: s11 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveGreaterThan [
	"AutoGenerated by Druid"

	| s11 s8 jump1 currentBlock jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndR: SendNumArgsReg R: Extra0Reg.
	self TstCq: 1 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpR: SendNumArgsReg R: ClassReg.
	jump2 := self JumpLessOrEqual: 0.
	s8 := objectMemory trueObject.
	self MoveCq: s8 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	s11 := objectMemory falseObject.
	self MoveCq: s11 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveIdentical [
	"AutoGenerated by Druid"

	| jump1 jump6 jump3 b450 s56 s53 b446 jump5 currentBlock jump2 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFF7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg R: Extra0Reg.
	b450 := self Label.
	self MoveR: Extra0Reg R: ClassReg.
	self AndCq: 7 R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: Extra0Reg R: ClassReg.
	self AndCq: 16r3FFFF7 R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: Extra0Reg R: ClassReg.
	self MoveR: ClassReg R: Extra0Reg.
	jump5 := self Jump: b450.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFF7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg R: Extra0Reg.
	b446 := self Label.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self AndCq: 7 R: SendNumArgsReg.
	self CmpCq: 0 R: SendNumArgsReg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: Extra0Reg R: SendNumArgsReg.
	self AndCq: 16r3FFFF7 R: SendNumArgsReg.
	self CmpCq: 0 R: SendNumArgsReg.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	jump6 := self Jump: b446.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpR: ClassReg R: SendNumArgsReg.
	jump3 := self JumpNonZero: 0.
	s53 := objectMemory trueObject.
	self MoveCq: s53 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s56 := objectMemory falseObject.
	self MoveCq: s56 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveIdentityHash [
	"AutoGenerated by Druid"

	| jump1 jump2 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self TstCq: 7 R: ClassReg.
	jump1 := self JumpNonZero: 0.
	self MoveM32: 4 r: ClassReg R: SendNumArgsReg.
	self AndCq: 16rFFFFFFFF R: SendNumArgsReg.
	self AndCq: 16r3FFFFF R: SendNumArgsReg.
	self CmpCq: 0 R: SendNumArgsReg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceNewHashTrampoline ].
	self MoveR: TempReg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 1 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 1 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveImmediateAsInteger [
	"AutoGenerated by Druid"

	| s27 s39 s60 s2 s24 currentBlock s63 s38 s3 |
	s2 := self methodNumArgs.
	s2 = 0 ifTrue: [
		| jump1 jump2 jump3 |
		self MoveR: ReceiverResultReg R: ClassReg.
		self TstCq: 1 R: ClassReg.
		jump1 := self JumpZero: 0.
		self ArithmeticShiftRightCq: 3 R: ClassReg.
		self LogicalShiftLeftCq: 3 R: ClassReg.
		self AddCq: 1 R: ClassReg.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self TstCq: 2 R: ClassReg.
		jump1 := self JumpZero: 0.
		self LogicalShiftRightCq: 3 R: ClassReg.
		self LogicalShiftLeftCq: 3 R: ClassReg.
		self AddCq: 1 R: ClassReg.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self TstCq: 4 R: ClassReg.
		jump1 := self JumpZero: 0.
		self MoveR: ClassReg R: SendNumArgsReg.
		self LogicalShiftRightCq: 4 R: SendNumArgsReg.
		self TstCq: 8 R: ClassReg.
		jump2 := self JumpZero: 0.
		s24 :=  -1152921504606846976.
		self MoveCq: s24 R: ClassReg.
		jump3 := self Jump: 0.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		s27 := 0.
		self MoveCq: s27 R: ClassReg.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		self AddR: ClassReg R: SendNumArgsReg.
		self MoveR: SendNumArgsReg R: ClassReg.
		self LogicalShiftLeftCq: 3 R: ClassReg.
		self AddCq: 1 R: ClassReg.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		^ 0 ].
	s38 := self methodNumArgs.
	s38 = 1 ifTrue: [
		| jump1 jump3 jump2 |
		self MoveR: Arg0Reg R: ClassReg.
		self TstCq: 1 R: ClassReg.
		jump1 := self JumpZero: 0.
		self ArithmeticShiftRightCq: 3 R: ClassReg.
		self LogicalShiftLeftCq: 3 R: ClassReg.
		self AddCq: 1 R: ClassReg.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self TstCq: 2 R: ClassReg.
		jump1 := self JumpZero: 0.
		self LogicalShiftRightCq: 3 R: ClassReg.
		self LogicalShiftLeftCq: 3 R: ClassReg.
		self AddCq: 1 R: ClassReg.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		self TstCq: 4 R: ClassReg.
		jump1 := self JumpZero: 0.
		self MoveR: ClassReg R: SendNumArgsReg.
		self LogicalShiftRightCq: 4 R: SendNumArgsReg.
		self TstCq: 8 R: ClassReg.
		jump3 := self JumpZero: 0.
		s60 :=  -1152921504606846976.
		self MoveCq: s60 R: ClassReg.
		jump2 := self Jump: 0.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		s63 := 0.
		self MoveCq: s63 R: ClassReg.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		self AddR: ClassReg R: SendNumArgsReg.
		self MoveR: SendNumArgsReg R: ClassReg.
		self LogicalShiftLeftCq: 3 R: ClassReg.
		self AddCq: 1 R: ClassReg.
		self MoveR: ClassReg R: ReceiverResultReg.
		self genPrimReturn.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		^ 0 ].
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveLessOrEqual [
	"AutoGenerated by Druid"

	| s11 s8 jump1 currentBlock jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndR: SendNumArgsReg R: Extra0Reg.
	self TstCq: 1 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpR: SendNumArgsReg R: ClassReg.
	jump2 := self JumpGreater: 0.
	s8 := objectMemory trueObject.
	self MoveCq: s8 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	s11 := objectMemory falseObject.
	self MoveCq: s11 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveLessThan [
	"AutoGenerated by Druid"

	| s11 s8 jump1 currentBlock jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndR: SendNumArgsReg R: Extra0Reg.
	self TstCq: 1 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpR: SendNumArgsReg R: ClassReg.
	jump2 := self JumpGreaterOrEqual: 0.
	s8 := objectMemory trueObject.
	self MoveCq: s8 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	s11 := objectMemory falseObject.
	self MoveCq: s11 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveMod [
	"AutoGenerated by Druid"

	| s48 s55 jump3 jump1 jump5 currentBlock jump4 jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndR: SendNumArgsReg R: Extra0Reg.
	self TstCq: 1 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self ArithmeticShiftRightCq: 3 R: Extra0Reg.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self CmpCq: 0 R: SendNumArgsReg.
	jump2 := self JumpZero: 0.
	self
		DivR: SendNumArgsReg
		R: Extra0Reg
		Quo: Extra1Reg
		Rem: Extra0Reg.
	self CmpCq: 0 R: SendNumArgsReg.
	jump3 := self JumpGreaterOrEqual: 0.
	self CmpCq: 0 R: Extra0Reg.
	jump4 := self JumpLessOrEqual: 0.
	self AddR: SendNumArgsReg R: Extra0Reg.
	self MoveR: Extra0Reg R: Extra1Reg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: Extra1Reg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 0 R: Extra0Reg.
	jump3 := self JumpGreaterOrEqual: 0.
	self AddR: SendNumArgsReg R: Extra0Reg.
	self MoveR: Extra0Reg R: Extra1Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: Extra1Reg.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveR: Extra1Reg R: Extra0Reg.
	self LogicalShiftRightCq: 60 R: Extra0Reg.
	self AddCq: 1 R: Extra0Reg.
	self AndCq: 15 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump5 := self JumpAbove: 0.
	self MoveR: Extra1Reg R: Extra0Reg.
	self LogicalShiftRightCq: 60 R: Extra0Reg.
	self AddCq: 1 R: Extra0Reg.
	self AndCq: 15 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpAbove: 0.
	self MoveR: Extra1Reg R: Extra0Reg.
	self LogicalShiftLeftCq: 3 R: Extra0Reg.
	self AddCq: 1 R: Extra0Reg.
	s48 := 0.
	self MoveCq: s48 R: Extra1Reg.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: ClassReg R: Extra1Reg.
	s55 := 1.
	self MoveR: Extra1Reg R: Extra0Reg.
	self MoveCq: s55 R: Extra1Reg.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ReceiverResultReg.
	self CmpCq: 0 R: Extra1Reg.
	jump3 := self JumpNonZero: 0.
	self genPrimReturn.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveMultiply [
	"AutoGenerated by Druid"

	| jump1 jump2 jump3 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self TstCq: 1 R: ClassReg.
	jump1 := self JumpZero: 0.
	self TstCq: 1 R: SendNumArgsReg.
	jump2 := self JumpZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self SubCq: 1 R: SendNumArgsReg.
	self MulR: ClassReg R: SendNumArgsReg.
	jump3 := self JumpMultiplyOverflow: 0.
	self AddCq: 1 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveNew [
	"AutoGenerated by Druid"

	| s34 jump1 jump6 jump3 b349 currentBlock jump8 jump5 jump2 s23 jump7 jump4 |
	self SubCq: 8 R: SPReg.
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveM64: 24 r: ClassReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self ArithmeticShiftRightCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self LogicalShiftRightCq: 16 R: Extra0Reg.
	self AndCq: 31 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump1 := self JumpBelowOrEqual: 0.
	self CmpCq: 5 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM32: 4 r: ClassReg R: ClassReg.
	self AndCq: 16rFFFFFFFF R: ClassReg.
	self AndCq: 16r3FFFFF R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump1 := self JumpZero: 0.
	self CmpCq: 0 R: ClassReg.
	jump3 := self JumpAboveOrEqual: 0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self AndCq: 16rFFFF R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self CmpCq: 255 R: Extra3Reg.
	jump3 := self JumpBelow: 0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self CmpCq: 1 R: Extra3Reg.
	jump3 := self JumpAboveOrEqual: 0.
	s23 := 8.
	self MoveCq: s23 R: Extra1Reg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra1Reg.
	self LogicalShiftLeftCq: 3 R: Extra1Reg.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self AddCq: 8 R: Extra1Reg.
	self MoveAw: objectMemory freeStartAddress R: Extra2Reg.
	self AddR: Extra1Reg R: Extra2Reg.
	s34 := objectMemory getScavengeThreshold.
	self CmpCq: s34 R: Extra2Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self CmpCq: s34 R: Extra2Reg.
	jump3 := self JumpAbove: 0.
	self MoveAw: objectMemory freeStartAddress R: Extra2Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: Extra2Reg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 56 R: SendNumArgsReg.
	self LogicalShiftLeftCq: 24 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self AddR: ClassReg R: SendNumArgsReg.
	self OrCq: 0 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg M64: 0 r: Extra2Reg.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self AddR: Extra1Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Aw: objectMemory freeStartAddress.
	self CmpCq: 0 R: Extra2Reg.
	jump7 := self JumpZero: 0.
	self genMoveConstant: objectMemory nilObject R: SendNumArgsReg.
	self MoveR: Extra2Reg R: Extra1Reg.
	self AddCq: 8 R: Extra1Reg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveR: Extra2Reg R: ClassReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self AddR: Extra3Reg R: ClassReg.
	self AddCq: 8 R: ClassReg.
	self SubCq: 1 R: ClassReg.
	b349 := self Label.
	self CmpR: Extra1Reg R: ClassReg.
	jump6 := self JumpLess: 0.
	self MoveR: SendNumArgsReg M64: 0 r: Extra1Reg.
	self MoveR: Extra1Reg R: Extra0Reg.
	self AddCq: 8 R: Extra0Reg.
	self MoveR: Extra0Reg R: Extra1Reg.
	jump8 := self Jump: b349.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self MoveR: Extra2Reg R: ReceiverResultReg.
	self AddCq: 8 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self AddCq: 8 R: SPReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveNewWithArg [
	"AutoGenerated by Druid"

	| jump5 s169 s81 s55 jump10 s184 jump3 s86 b690 s173 jump1 jump8 currentBlock s49 s195 s90 s7 s141 s106 s233 jump6 s40 jump11 jump4 jump13 s93 s63 jump2 s109 s102 jump9 jump14 jump7 jump12 s66 |
	self SubCq: 32 R: SPReg.
	self MoveR: ReceiverResultReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self TstCq: 1 R: SendNumArgsReg.
	jump1 := self JumpZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self CmpCq: 0 R: SendNumArgsReg.
	jump2 := self JumpGreaterOrEqual: 0.
	s7 := 1.
	self MoveCq: s7 R: ClassReg.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 24 r: Extra3Reg R: Extra0Reg.
	self ArithmeticShiftRightCq: 3 R: Extra0Reg.
	self MoveR: Extra0Reg R: Extra1Reg.
	self LogicalShiftRightCq: 16 R: Extra1Reg.
	self AndCq: 31 R: Extra1Reg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM32: 4 r: Extra3Reg R: Extra3Reg.
	self AndCq: 16rFFFFFFFF R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AndCq: 16r3FFFFF R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self CmpCq: 2 R: Extra1Reg.
	jump2 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	self MoveR: Extra0Reg R: ClassReg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 3 R: Extra1Reg.
	jump2 := self JumpNonZero: 0.
	self AndCq: 16rFFFF R: Extra0Reg.
	self AddR: SendNumArgsReg R: Extra0Reg.
	self genMoveConstant: objectMemory nilObject R: ClassReg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 4 R: Extra1Reg.
	jump2 := self JumpNonZero: 0.
	self AndCq: 16rFFFF R: Extra0Reg.
	self AddR: SendNumArgsReg R: Extra0Reg.
	self genMoveConstant: objectMemory nilObject R: ClassReg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	s40 := 0.
	self CmpCq: 9 R: Extra1Reg.
	jump2 := self JumpNonZero: 0.
	self MoveCq: s40 R: ClassReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 10 R: Extra1Reg.
	jump2 := self JumpNonZero: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 34 R: Extra3Reg.
	jump8 := self JumpNonZero: 0.
	self CmpCq: 2 R: SendNumArgsReg.
	jump9 := self JumpZero: 0.
	s49 := 1.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: SendNumArgsReg.
	self MoveCq: s49 R: ClassReg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ClassReg.
	self AddCq: 1 R: ClassReg.
	s55 := 2.
	self MoveCq: s55 R: Extra0Reg.
	self
		DivR: Extra0Reg
		R: ClassReg
		Quo: Extra0Reg
		Rem: ClassReg.
	self AndCq: 1 R: SendNumArgsReg.
	self AddR: SendNumArgsReg R: Extra1Reg.
	self MoveR: Extra0Reg R: ClassReg.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s63 := 0.
	self MoveR: SendNumArgsReg R: ClassReg.
	self AddCq: 1 R: ClassReg.
	s66 := 2.
	self MoveCq: s66 R: Extra0Reg.
	self
		DivR: Extra0Reg
		R: ClassReg
		Quo: Extra0Reg
		Rem: ClassReg.
	self AndCq: 1 R: SendNumArgsReg.
	self AddR: SendNumArgsReg R: Extra1Reg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 0 R: Extra3Reg.
	jump8 := self JumpNonZero: 0.
	self MoveCq: s63 R: ClassReg.
	jump11 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	s81 := 0.
	self MoveCq: s81 R: Extra0Reg.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	s86 := 0.
	self CmpCq: 12 R: Extra1Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: ClassReg.
	self AddCq: 3 R: ClassReg.
	s90 := 4.
	self MoveCq: s90 R: Extra0Reg.
	self
		DivR: Extra0Reg
		R: ClassReg
		Quo: Extra2Reg
		Rem: Extra0Reg.
	s93 := 4.
	self MoveCq: s93 R: Extra0Reg.
	self SubR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 3 R: Extra0Reg.
	self AddR: Extra0Reg R: Extra1Reg.
	self MoveCq: s86 R: ClassReg.
	self MoveR: Extra2Reg R: SendNumArgsReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	s102 := 0.
	self CmpCq: 16 R: Extra1Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AddCq: 7 R: Extra0Reg.
	s106 := 8.
	self MoveCq: s106 R: Extra2Reg.
	self
		DivR: Extra2Reg
		R: Extra0Reg
		Quo: Extra0Reg
		Rem: Extra2Reg.
	s109 := 8.
	self MoveCq: s109 R: Extra2Reg.
	self SubR: SendNumArgsReg R: Extra2Reg.
	self AndCq: 7 R: Extra2Reg.
	self AddR: Extra2Reg R: Extra1Reg.
	self MoveCq: s102 R: ClassReg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	jump12 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 0 R: SendNumArgsReg.
	jump2 := self JumpNonZero: 0.
	self CmpCq: 5 R: Extra1Reg.
	jump13 := self JumpAbove: 0.
	self AndCq: 16rFFFF R: Extra0Reg.
	self genMoveConstant: objectMemory nilObject R: Extra2Reg.
	self MoveR: Extra2Reg R: ClassReg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 0 R: Extra3Reg.
	jump12 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM32: 4 r: Extra3Reg R: Extra2Reg.
	self AndCq: 16rFFFFFFFF R: Extra2Reg.
	self AndCq: 16r3FFFFF R: Extra2Reg.
	self CmpCq: 0 R: Extra2Reg.
	jump11 := self JumpZero: 0.
	self CmpCq: 0 R: Extra2Reg.
	jump8 := self JumpAboveOrEqual: 0.
	s141 := 1.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: SendNumArgsReg.
	self MoveCq: s141 R: ClassReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveR: ClassReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 16 r: SPReg.
	self MoveR: Extra0Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 24 r: SPReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump12 jmpTarget: currentBlock.
	self MoveR: ClassReg R: Extra0Reg.
	self MoveR: SendNumArgsReg R: ClassReg.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 16 r: SPReg.
	self MoveR: ClassReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 24 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra2Reg.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self CmpCq: 16rFFFF R: Extra3Reg.
	jump8 := self JumpBelowOrEqual: 0.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self CmpCq: 16r10000000000 R: Extra3Reg.
	jump9 := self JumpBelowOrEqual: 0.
	s169 := 1.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: SendNumArgsReg.
	self MoveCq: s169 R: ClassReg.
	jump12 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	s173 := 1.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: SendNumArgsReg.
	self MoveCq: s173 R: ClassReg.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self CmpCq: 255 R: Extra3Reg.
	jump8 := self JumpBelow: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra2Reg.
	self MoveR: Extra2Reg R: ReceiverResultReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self CmpCq: 1 R: Extra3Reg.
	jump8 := self JumpAboveOrEqual: 0.
	s184 := 8.
	self MoveCq: s184 R: ClassReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	self LogicalShiftLeftCq: 3 R: ClassReg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self AddCq: 8 R: ClassReg.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self AddR: ClassReg R: SendNumArgsReg.
	s195 := objectMemory getScavengeThreshold.
	self CmpCq: s195 R: SendNumArgsReg.
	jump5 := self JumpBelowOrEqual: 0.
	self CmpCq: s195 R: SendNumArgsReg.
	jump8 := self JumpBelowOrEqual: 0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self LogicalShiftLeftCq: 56 R: Extra0Reg.
	self LogicalShiftLeftCq: 24 R: Extra1Reg.
	self AddR: Extra1Reg R: Extra0Reg.
	self AddR: Extra2Reg R: Extra0Reg.
	self OrCq: 0 R: Extra0Reg.
	self MoveR: Extra0Reg M64: 0 r: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddR: ClassReg R: Extra0Reg.
	self MoveR: Extra0Reg Aw: objectMemory freeStartAddress.
	self CmpCq: 0 R: SendNumArgsReg.
	jump8 := self JumpNonZero: 0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AddCq: 8 R: Extra0Reg.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 24 r: SPReg.
	self MoveR: SendNumArgsReg R: ClassReg.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self AddR: Extra3Reg R: ClassReg.
	self AddCq: 8 R: ClassReg.
	self SubCq: 1 R: ClassReg.
	b690 := self Label.
	self CmpR: Extra0Reg R: ClassReg.
	jump8 := self JumpLess: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg M64: 0 r: Extra0Reg.
	self MoveR: Extra0Reg R: Extra2Reg.
	self AddCq: 8 R: Extra2Reg.
	self MoveR: Extra2Reg R: Extra0Reg.
	jump14 := self Jump: b690.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s233 := 0.
	self MoveCq: s233 R: ClassReg.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump10 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump12 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self CmpCq: 0 R: ClassReg.
	jump9 := self JumpNonZero: 0.
	self AddCq: 32 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump13 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self AddCq: 32 R: SPReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveNotEqual [
	"AutoGenerated by Druid"

	| s11 s8 jump1 currentBlock jump2 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndR: SendNumArgsReg R: Extra0Reg.
	self TstCq: 1 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpR: SendNumArgsReg R: ClassReg.
	jump2 := self JumpZero: 0.
	s8 := objectMemory trueObject.
	self MoveCq: s8 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	s11 := objectMemory falseObject.
	self MoveCq: s11 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveNotIdentical [
	"AutoGenerated by Druid"

	| jump1 jump6 jump3 b450 s56 s53 b446 jump5 currentBlock jump2 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFF7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg R: Extra0Reg.
	b450 := self Label.
	self MoveR: Extra0Reg R: ClassReg.
	self AndCq: 7 R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 0 r: Extra0Reg R: ClassReg.
	self AndCq: 16r3FFFF7 R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 8 r: Extra0Reg R: ClassReg.
	self MoveR: ClassReg R: Extra0Reg.
	jump5 := self Jump: b450.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFF7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg R: Extra0Reg.
	b446 := self Label.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self AndCq: 7 R: SendNumArgsReg.
	self CmpCq: 0 R: SendNumArgsReg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 0 r: Extra0Reg R: SendNumArgsReg.
	self AndCq: 16r3FFFF7 R: SendNumArgsReg.
	self CmpCq: 0 R: SendNumArgsReg.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	jump6 := self Jump: b446.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpR: ClassReg R: SendNumArgsReg.
	jump3 := self JumpZero: 0.
	s53 := objectMemory trueObject.
	self MoveCq: s53 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s56 := objectMemory falseObject.
	self MoveCq: s56 R: ReceiverResultReg.
	self genPrimReturn.
	^ CompletePrimitive
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveQuo [
	"AutoGenerated by Druid"

	| jump1 s31 s39 s36 jump3 jump6 s18 currentBlock s27 jump5 jump2 s14 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self TstCq: 1 R: ClassReg.
	jump1 := self JumpZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self TstCq: 1 R: SendNumArgsReg.
	jump2 := self JumpZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self CmpCq: 0 R: SendNumArgsReg.
	jump3 := self JumpZero: 0.
	self CmpCq: 0 R: ClassReg.
	jump4 := self JumpLessOrEqual: 0.
	self CmpCq: 0 R: SendNumArgsReg.
	jump5 := self JumpLessOrEqual: 0.
	self
		DivR: SendNumArgsReg
		R: ClassReg
		Quo: ClassReg
		Rem: SendNumArgsReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	s14 := 0.
	self MoveCq: s14 R: Extra0Reg.
	self SubR: SendNumArgsReg R: Extra0Reg.
	self
		DivR: Extra0Reg
		R: ClassReg
		Quo: SendNumArgsReg
		Rem: Extra0Reg.
	s18 := 0.
	self MoveCq: s18 R: Extra0Reg.
	self SubR: SendNumArgsReg R: Extra0Reg.
	self MoveR: Extra0Reg R: ClassReg.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self MoveR: ClassReg R: Extra0Reg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 0 R: SendNumArgsReg.
	jump4 := self JumpLessOrEqual: 0.
	s27 := 0.
	self MoveCq: s27 R: Extra0Reg.
	self SubR: ClassReg R: Extra0Reg.
	self
		DivR: SendNumArgsReg
		R: Extra0Reg
		Quo: SendNumArgsReg
		Rem: Extra0Reg.
	s31 := 0.
	self MoveCq: s31 R: Extra0Reg.
	self SubR: SendNumArgsReg R: Extra0Reg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	s36 := 0.
	self MoveCq: s36 R: Extra0Reg.
	self SubR: ClassReg R: Extra0Reg.
	s39 := 0.
	self MoveCq: s39 R: ClassReg.
	self SubR: SendNumArgsReg R: ClassReg.
	self
		DivR: ClassReg
		R: Extra0Reg
		Quo: Extra0Reg
		Rem: ClassReg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftRightCq: 60 R: ClassReg.
	self AddCq: 1 R: ClassReg.
	self AndCq: 15 R: ClassReg.
	self CmpCq: 1 R: ClassReg.
	jump6 := self JumpAbove: 0.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 3 R: ClassReg.
	self AddCq: 1 R: ClassReg.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveSize [
	"AutoGenerated by Druid"

	| jump1 jumpNext jump6 jump3 s108 currentBlock jump8 jump5 jumpTrue jump2 s159 s14 jump7 jump4 |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: ClassReg R: Extra1Reg.
	self CmpCq: 7 R: Extra1Reg.
	jumpTrue := self JumpNonZero: 0.
	self MoveCq: 0 R: Extra1Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra1Reg.
	jumpNext jmpTarget: self Label.
	self TstCq: 7 R: ClassReg.
	jump1 := self JumpZero: 0.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra1Reg.
	self AndCq: 16r3FFFF7 R: Extra1Reg.
	s14 := 0.
	self MoveR: Extra1Reg R: Extra2Reg.
	self CmpCq: s14 R: Extra2Reg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: Extra2Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra2Reg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 0 R: Extra1Reg.
	jump1 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 24 R: Extra0Reg.
	self AndCq: 31 R: Extra0Reg.
	self MoveR: Extra0Reg R: Extra2Reg.
	self CmpCq: 2 R: Extra2Reg.
	jumpTrue := self JumpBelow: 0.
	self MoveCq: 0 R: Extra2Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra2Reg.
	jumpNext jmpTarget: self Label.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveR: Extra2Reg R: Extra1Reg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra1Reg.
	jump2 := self JumpZero: 0.
	self CmpCq: 3 R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self AndCq: 16r3FFFFF R: SendNumArgsReg.
	self CmpCq: 36 R: SendNumArgsReg.
	jump1 := self JumpZero: 0.
	self MoveMb: 7 r: ClassReg R: Extra2Reg.
	self AndCq: 255 R: Extra2Reg.
	self CmpCq: 255 R: Extra2Reg.
	jump4 := self JumpNonZero: 0.
	self MoveM64: -8 r: ClassReg R: Extra2Reg.
	self LogicalShiftLeftCq: 8 R: Extra2Reg.
	self LogicalShiftRightCq: 8 R: Extra2Reg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self MoveMb: 7 r: ClassReg R: Extra2Reg.
	self AndCq: 255 R: Extra2Reg.
	self CmpCq: 255 R: Extra2Reg.
	jump3 := self JumpNonZero: 0.
	self MoveM64: -8 r: ClassReg R: Extra2Reg.
	self LogicalShiftLeftCq: 8 R: Extra2Reg.
	self LogicalShiftRightCq: 8 R: Extra2Reg.
	self CmpCq: 5 R: Extra0Reg.
	jump6 := self JumpAbove: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	self CmpCq: 5 R: Extra0Reg.
	jump3 := self JumpAbove: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 16 R: Extra0Reg.
	jump6 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 3 R: Extra2Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self AndCq: 7 R: SendNumArgsReg.
	self SubR: SendNumArgsReg R: Extra2Reg.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 12 R: Extra0Reg.
	jump6 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 2 R: Extra2Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self AndCq: 3 R: SendNumArgsReg.
	self SubR: SendNumArgsReg R: Extra2Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 10 R: Extra0Reg.
	jump6 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 1 R: Extra2Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self AndCq: 1 R: SendNumArgsReg.
	self SubR: SendNumArgsReg R: Extra2Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	s108 := 0.
	self MoveCq: s108 R: Extra2Reg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra0Reg.
	jump8 := self JumpBelow: 0.
	self SubCq: 0 R: Extra2Reg.
	self MoveR: Extra2Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 1 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self CmpCq: 2 R: Extra0Reg.
	jump8 := self JumpNonZero: 0.
	self SubCq: 0 R: Extra2Reg.
	self MoveR: Extra2Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 1 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self CmpCq: 2 R: Extra0Reg.
	jump8 := self JumpAboveOrEqual: 0.
	self SubR: Extra2Reg R: Extra2Reg.
	self MoveR: Extra2Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 1 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: SendNumArgsReg.
	self AndCq: 16r3FFFFF R: SendNumArgsReg.
	self CmpCq: 31 R: SendNumArgsReg.
	jump8 := self JumpAbove: 0.
	self CmpCq: 31 R: SendNumArgsReg.
	jump7 := self JumpNonZero: 0.
	self MoveM64: 24 r: ClassReg R: SendNumArgsReg.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self AndCq: 16rFFFF R: SendNumArgsReg.
	self SubR: SendNumArgsReg R: Extra2Reg.
	self MoveR: Extra2Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 1 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 8 R: SendNumArgsReg.
	jump7 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: SendNumArgsReg.
	self MoveM64: 24 r: SendNumArgsReg R: SendNumArgsReg.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self AndCq: 16rFFFF R: SendNumArgsReg.
	self SubR: SendNumArgsReg R: Extra2Reg.
	self MoveR: Extra2Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 1 R: SendNumArgsReg.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ClassReg.
	self LogicalShiftRightCq: 10 R: ClassReg.
	s159 := objectMemory hiddenRootsObject.
	self LogicalShiftLeftCq: 3 R: ClassReg.
	self AddCq: s159 R: ClassReg.
	self MoveM64: 8 r: ClassReg R: ClassReg.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	self CmpR: Extra0Reg R: ClassReg.
	jump7 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self AndCq: 1023 R: SendNumArgsReg.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddR: SendNumArgsReg R: ClassReg.
	self MoveM64: 8 r: ClassReg R: Extra0Reg.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveM64: 24 r: Extra0Reg R: Extra0Reg.
	self ArithmeticShiftRightCq: 3 R: Extra0Reg.
	self AndCq: 16rFFFF R: Extra0Reg.
	self SubR: Extra0Reg R: Extra2Reg.
	self MoveR: Extra2Reg R: Extra0Reg.
	self LogicalShiftLeftCq: 3 R: Extra0Reg.
	self AddCq: 1 R: Extra0Reg.
	self MoveR: Extra0Reg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveSmallFloatAdd [
	"AutoGenerated by Druid"

	| jump1 s123 jumpNext s98 s126 jump9 jump6 jump3 jump10 currentBlock s91 jump5 jump2 jump8 jumpTrue jump11 jump7 jump4 |
	self mclassIsSmallFloat ifFalse: [ ^ UnimplementedPrimitive ].
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self AddRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: Extra0Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftRightCq: 52 R: SendNumArgsReg.
	self AndCq: 2047 R: SendNumArgsReg.
	self CmpCq: 896 R: SendNumArgsReg.
	jump8 := self JumpBelowOrEqual: 0.
	self CmpCq: 1151 R: SendNumArgsReg.
	jump7 := self JumpBelowOrEqual: 0.
	jump9 := self JumpAbove: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self AndCq: 16rFFFFFFFFFFFFF R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump8 := self JumpNonZero: 0.
	s91 := 0.
	self CmpCq: s91 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: SendNumArgsReg.
	jump10 := self JumpZero: 0.
	jump11 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s98 := 896.
	self CmpCq: s98 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: SendNumArgsReg.
	jump8 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveRd: DPFPReg0 R: SendNumArgsReg.
	self RotateLeftCq: 1 R: SendNumArgsReg.
	self CmpCq: 1 R: SendNumArgsReg.
	jump7 := self JumpBelowOrEqual: 0.
	self SubCq: 16r7000000000000000 R: SendNumArgsReg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 4 R: SendNumArgsReg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	s123 := objectMemory getScavengeThreshold.
	self CmpCq: s123 R: Extra0Reg.
	jump9 := self JumpAbove: 0.
	s126 := 72057594205700130.
	self MoveCq: s126 R: Extra0Reg.
	self MoveR: Extra0Reg M64: 0 r: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	self MoveR: Extra0Reg Aw: objectMemory freeStartAddress.
	self MoveRd: DPFPReg0 M64: 8 r: SendNumArgsReg.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveSmallFloatDivide [
	"AutoGenerated by Druid"

	| jump1 jump10 s100 jumpNext jump9 jump6 jump3 s128 s125 currentBlock jump5 jump2 jump8 jumpTrue s96 jump7 jump4 |
	self mclassIsSmallFloat ifFalse: [ ^ UnimplementedPrimitive ].
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self MoveCq: (objectMemory rawFloatBitsOf: 0.0) R: Extra0Reg.
	self MoveR: Extra0Reg Rd: DPFPReg2.
	self CmpRd: DPFPReg2 Rd: DPFPReg1.
	jump8 := self JumpFPEqual: 0.
	self DivRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: Extra0Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftRightCq: 52 R: SendNumArgsReg.
	self AndCq: 2047 R: SendNumArgsReg.
	self CmpCq: 896 R: SendNumArgsReg.
	jump7 := self JumpBelowOrEqual: 0.
	self CmpCq: 1151 R: SendNumArgsReg.
	jumpTrue := self JumpBelowOrEqual: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self AndCq: 16rFFFFFFFFFFFFF R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump7 := self JumpNonZero: 0.
	s96 := 0.
	self CmpCq: s96 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	s100 := 896.
	self CmpCq: s100 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self CmpCq: 1 R: SendNumArgsReg.
	jump9 := self JumpNonZero: 0.
	self MoveRd: DPFPReg0 R: SendNumArgsReg.
	self RotateLeftCq: 1 R: SendNumArgsReg.
	self CmpCq: 1 R: SendNumArgsReg.
	jump10 := self JumpBelowOrEqual: 0.
	self SubCq: 16r7000000000000000 R: SendNumArgsReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 4 R: SendNumArgsReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	s125 := objectMemory getScavengeThreshold.
	self CmpCq: s125 R: Extra0Reg.
	jump9 := self JumpAbove: 0.
	s128 := 72057594205700130.
	self MoveCq: s128 R: Extra0Reg.
	self MoveR: Extra0Reg M64: 0 r: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	self MoveR: Extra0Reg Aw: objectMemory freeStartAddress.
	self MoveRd: DPFPReg0 M64: 8 r: SendNumArgsReg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveSmallFloatEqual [
	"AutoGenerated by Druid"

	| jump1 s86 s83 jump6 jump3 currentBlock jump8 jump5 jump2 jump7 jump4 |
	self mclassIsSmallFloat ifFalse: [ ^ UnimplementedPrimitive ].
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jump8 := self JumpFPNotEqual: 0.
	s83 := objectMemory trueObject.
	self MoveCq: s83 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s86 := objectMemory falseObject.
	self MoveCq: s86 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveSmallFloatGreaterOrEqual [
	"AutoGenerated by Druid"

	| jump1 s86 s83 jump6 jump3 currentBlock jump8 jump5 jump2 jump7 jump4 |
	self mclassIsSmallFloat ifFalse: [ ^ UnimplementedPrimitive ].
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jump8 := self JumpFPLess: 0.
	s83 := objectMemory trueObject.
	self MoveCq: s83 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s86 := objectMemory falseObject.
	self MoveCq: s86 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveSmallFloatGreaterThan [
	"AutoGenerated by Druid"

	| jump1 s86 s83 jump6 jump3 currentBlock jump8 jump5 jump2 jump7 jump4 |
	self mclassIsSmallFloat ifFalse: [ ^ UnimplementedPrimitive ].
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jump8 := self JumpFPLessOrEqual: 0.
	s83 := objectMemory trueObject.
	self MoveCq: s83 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s86 := objectMemory falseObject.
	self MoveCq: s86 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveSmallFloatLessOrEqual [
	"AutoGenerated by Druid"

	| jump1 s86 s83 jump6 jump3 currentBlock jump8 jump5 jump2 jump7 jump4 |
	self mclassIsSmallFloat ifFalse: [ ^ UnimplementedPrimitive ].
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jump8 := self JumpFPGreater: 0.
	s83 := objectMemory trueObject.
	self MoveCq: s83 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s86 := objectMemory falseObject.
	self MoveCq: s86 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveSmallFloatLessThan [
	"AutoGenerated by Druid"

	| jump1 s86 s83 jump6 jump3 currentBlock jump8 jump5 jump2 jump7 jump4 |
	self mclassIsSmallFloat ifFalse: [ ^ UnimplementedPrimitive ].
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jump8 := self JumpFPGreaterOrEqual: 0.
	s83 := objectMemory trueObject.
	self MoveCq: s83 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s86 := objectMemory falseObject.
	self MoveCq: s86 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveSmallFloatMultiply [
	"AutoGenerated by Druid"

	| jump1 s123 jumpNext s98 s126 jump9 jump6 jump3 jump10 currentBlock s91 jump5 jump2 jump8 jumpTrue jump11 jump7 jump4 |
	self mclassIsSmallFloat ifFalse: [ ^ UnimplementedPrimitive ].
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self MulRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: Extra0Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftRightCq: 52 R: SendNumArgsReg.
	self AndCq: 2047 R: SendNumArgsReg.
	self CmpCq: 896 R: SendNumArgsReg.
	jump8 := self JumpBelowOrEqual: 0.
	self CmpCq: 1151 R: SendNumArgsReg.
	jump7 := self JumpBelowOrEqual: 0.
	jump9 := self JumpAbove: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self AndCq: 16rFFFFFFFFFFFFF R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump8 := self JumpNonZero: 0.
	s91 := 0.
	self CmpCq: s91 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: SendNumArgsReg.
	jump10 := self JumpZero: 0.
	jump11 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s98 := 896.
	self CmpCq: s98 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: SendNumArgsReg.
	jump8 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveRd: DPFPReg0 R: SendNumArgsReg.
	self RotateLeftCq: 1 R: SendNumArgsReg.
	self CmpCq: 1 R: SendNumArgsReg.
	jump7 := self JumpBelowOrEqual: 0.
	self SubCq: 16r7000000000000000 R: SendNumArgsReg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 4 R: SendNumArgsReg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	s123 := objectMemory getScavengeThreshold.
	self CmpCq: s123 R: Extra0Reg.
	jump9 := self JumpAbove: 0.
	s126 := 72057594205700130.
	self MoveCq: s126 R: Extra0Reg.
	self MoveR: Extra0Reg M64: 0 r: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	self MoveR: Extra0Reg Aw: objectMemory freeStartAddress.
	self MoveRd: DPFPReg0 M64: 8 r: SendNumArgsReg.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveSmallFloatNotEqual [
	"AutoGenerated by Druid"

	| jump1 s86 s83 jump6 jump3 currentBlock jump8 jump5 jump2 jump7 jump4 |
	self mclassIsSmallFloat ifFalse: [ ^ UnimplementedPrimitive ].
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpRd: DPFPReg1 Rd: DPFPReg0.
	jump8 := self JumpFPNotEqual: 0.
	s83 := objectMemory falseObject.
	self MoveCq: s83 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s86 := objectMemory trueObject.
	self MoveCq: s86 R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveSmallFloatSubtract [
	"AutoGenerated by Druid"

	| jump1 s123 jumpNext s98 s126 jump9 jump6 jump3 jump10 currentBlock s91 jump5 jump2 jump8 jumpTrue jump11 jump7 jump4 |
	self mclassIsSmallFloat ifFalse: [ ^ UnimplementedPrimitive ].
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self MoveR: ClassReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump3 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	self LogicalShiftLeftCq: 63 R: ClassReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: ClassReg.
	self MoveR: ClassReg Rd: DPFPReg0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump2 := self JumpNonZero: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: ClassReg R: Extra0Reg.
	jump3 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: ClassReg.
	self ConvertR: ClassReg Rd: DPFPReg0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveM64: 0 r: ClassReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: ClassReg Rd: DPFPReg0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self AndCq: 7 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump5 := self JumpZero: 0.
	self CmpCq: 4 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 3 R: Extra0Reg.
	self CmpCq: 1 R: Extra0Reg.
	jump6 := self JumpBelowOrEqual: 0.
	self AddCq: 16r7000000000000000 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftLeftCq: 63 R: SendNumArgsReg.
	self LogicalShiftRightCq: 1 R: Extra0Reg.
	self AddR: Extra0Reg R: SendNumArgsReg.
	self MoveR: SendNumArgsReg Rd: DPFPReg1.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 1 R: Extra0Reg.
	jump4 := self JumpNonZero: 0.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftLeftCq: 9 R: Extra0Reg.
	self ArithmeticShiftRightCq: 9 R: Extra0Reg.
	self CmpR: SendNumArgsReg R: Extra0Reg.
	jump6 := self JumpNonZero: 0.
	self ArithmeticShiftRightCq: 3 R: SendNumArgsReg.
	self ConvertR: SendNumArgsReg Rd: DPFPReg1.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: SendNumArgsReg R: Extra0Reg.
	self AndCq: 16r3FFFFF R: Extra0Reg.
	self CmpCq: 34 R: Extra0Reg.
	jump5 := self JumpNonZero: 0.
	self MoveM64: 8 r: SendNumArgsReg Rd: DPFPReg1.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self SubRd: DPFPReg1 Rd: DPFPReg0.
	self MoveRd: DPFPReg0 R: Extra0Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self LogicalShiftRightCq: 52 R: SendNumArgsReg.
	self AndCq: 2047 R: SendNumArgsReg.
	self CmpCq: 896 R: SendNumArgsReg.
	jump8 := self JumpBelowOrEqual: 0.
	self CmpCq: 1151 R: SendNumArgsReg.
	jump7 := self JumpBelowOrEqual: 0.
	jump9 := self JumpAbove: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self AndCq: 16rFFFFFFFFFFFFF R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump8 := self JumpNonZero: 0.
	s91 := 0.
	self CmpCq: s91 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: SendNumArgsReg.
	jump10 := self JumpZero: 0.
	jump11 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s98 := 896.
	self CmpCq: s98 R: SendNumArgsReg.
	jumpTrue := self JumpZero: 0.
	self MoveCq: 0 R: SendNumArgsReg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: SendNumArgsReg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: SendNumArgsReg.
	jump8 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveRd: DPFPReg0 R: SendNumArgsReg.
	self RotateLeftCq: 1 R: SendNumArgsReg.
	self CmpCq: 1 R: SendNumArgsReg.
	jump7 := self JumpBelowOrEqual: 0.
	self SubCq: 16r7000000000000000 R: SendNumArgsReg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: 4 R: SendNumArgsReg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	self MoveAw: objectMemory freeStartAddress R: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	s123 := objectMemory getScavengeThreshold.
	self CmpCq: s123 R: Extra0Reg.
	jump9 := self JumpAbove: 0.
	s126 := 72057594205700130.
	self MoveCq: s126 R: Extra0Reg.
	self MoveR: Extra0Reg M64: 0 r: SendNumArgsReg.
	self MoveAw: objectMemory freeStartAddress R: Extra0Reg.
	self AddCq: 16 R: Extra0Reg.
	self MoveR: Extra0Reg Aw: objectMemory freeStartAddress.
	self MoveRd: DPFPReg0 M64: 8 r: SendNumArgsReg.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveStringAt [
	"AutoGenerated by Druid"

	| jump1 jump6 jump3 s71 s56 currentBlock s91 jump5 jump2 jump8 jump7 jump4 |
	self SubCq: 24 R: SPReg.
	self MoveR: ReceiverResultReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveR: Arg0Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self TstCq: 7 R: Extra3Reg.
	jump1 := self JumpZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: SendNumArgsReg.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra0Reg.
	self AndCq: 1 R: Extra0Reg.
	self CmpCq: 0 R: Extra0Reg.
	jump1 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: SendNumArgsReg.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self ArithmeticShiftRightCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 16 r: SPReg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra1Reg.
	self LogicalShiftRightCq: 24 R: Extra1Reg.
	self AndCq: 31 R: Extra1Reg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMb: 7 r: Extra3Reg R: Extra2Reg.
	self AndCq: 255 R: Extra2Reg.
	self CmpCq: 255 R: Extra2Reg.
	jump1 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: -8 r: Extra3Reg R: Extra2Reg.
	self LogicalShiftLeftCq: 8 R: Extra2Reg.
	self LogicalShiftRightCq: 8 R: Extra2Reg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 5 R: Extra1Reg.
	jump4 := self JumpAbove: 0.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 16 R: Extra1Reg.
	jump4 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 3 R: Extra2Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self AndCq: 7 R: ClassReg.
	self SubR: ClassReg R: Extra2Reg.
	self MoveR: Extra2Reg R: ClassReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 12 R: Extra1Reg.
	jump4 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 2 R: Extra2Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self AndCq: 3 R: ClassReg.
	self SubR: ClassReg R: Extra2Reg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 10 R: Extra1Reg.
	jump4 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 1 R: Extra2Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self AndCq: 1 R: ClassReg.
	self SubR: ClassReg R: Extra2Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra1Reg.
	jump4 := self JumpNonZero: 0.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	s56 := 0.
	self MoveCq: s56 R: Extra2Reg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra1Reg.
	jump8 := self JumpBelow: 0.
	self MoveR: Extra2Reg R: ClassReg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self CmpCq: 2 R: Extra1Reg.
	jump8 := self JumpNonZero: 0.
	self MoveR: Extra2Reg R: ClassReg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	s71 := 0.
	self MoveCq: s71 R: SendNumArgsReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self CmpCq: 2 R: Extra1Reg.
	jump8 := self JumpAboveOrEqual: 0.
	self MoveR: Extra2Reg R: SendNumArgsReg.
	self MoveR: Extra2Reg R: ClassReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: ClassReg.
	self AndCq: 16r3FFFFF R: ClassReg.
	self CmpCq: 31 R: ClassReg.
	jump8 := self JumpAbove: 0.
	self CmpCq: 31 R: ClassReg.
	jump6 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ClassReg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 8 R: ClassReg.
	jump6 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: ClassReg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	self MoveR: ClassReg R: SendNumArgsReg.
	self LogicalShiftRightCq: 10 R: SendNumArgsReg.
	s91 := objectMemory hiddenRootsObject.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddCq: s91 R: SendNumArgsReg.
	self MoveM64: 8 r: SendNumArgsReg R: SendNumArgsReg.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	self CmpR: Extra0Reg R: SendNumArgsReg.
	jump6 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: Extra0Reg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self AndCq: 1023 R: ClassReg.
	self LogicalShiftLeftCq: 3 R: ClassReg.
	self AddR: ClassReg R: SendNumArgsReg.
	self MoveM64: 8 r: SendNumArgsReg R: Extra0Reg.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self MoveR: Extra0Reg R: ClassReg.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveM64: 24 r: ClassReg R: Extra0Reg.
	self ArithmeticShiftRightCq: 3 R: Extra0Reg.
	self AndCq: 16rFFFF R: Extra0Reg.
	self MoveR: Extra0Reg R: SendNumArgsReg.
	self MoveR: Extra2Reg R: ClassReg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 3 R: Extra1Reg.
	jump7 := self JumpNonZero: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self AndCq: 16r3FFFFF R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 16 r: SPReg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self CmpCq: 36 R: Extra3Reg.
	jump5 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: SendNumArgsReg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self SubR: SendNumArgsReg R: ClassReg.
	self CmpCq: 24 R: Extra1Reg.
	jump5 := self JumpBelow: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: SendNumArgsReg.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: ReceiverResultReg.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 1 R: Extra3Reg.
	jump5 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpR: ClassReg R: Extra3Reg.
	jump3 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AddR: SendNumArgsReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self CmpCq: 5 R: Extra1Reg.
	jump2 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 8 r: Extra3Reg R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 16 R: Extra1Reg.
	jump2 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveMw: 0 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AddCq:  -1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveMb: 8 r: Extra3Reg R: Extra0Reg.
	self AndCq: 255 R: Extra0Reg.
	self LogicalShiftLeftCq: 3 R: Extra0Reg.
	self AddCq: 1 R: Extra0Reg.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 12 R: Extra1Reg.
	jump2 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM16: 8 r: Extra3Reg R: Extra0Reg.
	self AndCq: 16rFFFF R: Extra0Reg.
	self LogicalShiftLeftCq: 3 R: Extra0Reg.
	self AddCq: 1 R: Extra0Reg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra1Reg.
	jump2 := self JumpNonZero: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 8 r: Extra3Reg R: Extra0Reg.
	self CmpCq: 16rFFFFFFFFFFFFFFF R: Extra0Reg.
	jump6 := self JumpAbove: 0.
	self LogicalShiftLeftCq: 3 R: Extra0Reg.
	self AddCq: 1 R: Extra0Reg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self CmpCq: 0 R: Extra0Reg.
	jump8 := self JumpLess: 0.
	self CmpCq: 16r3FFFFFFF R: Extra0Reg.
	jump1 := self JumpGreater: 0.
	self ArithmeticShiftRightCq: 3 R: Extra0Reg.
	self LogicalShiftLeftCq: 3 R: Extra0Reg.
	self AddCq: 2 R: Extra0Reg.
	self MoveR: Extra0Reg R: ReceiverResultReg.
	self AddCq: 24 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self AddCq: 24 R: SPReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveStringAtPut [
	"AutoGenerated by Druid"

	| jump5 s192 jump10 jump3 jump15 jump8 jump1 s143 currentBlock jump13 jumpNext jump6 s148 jump11 jump4 s146 s185 jumpTrue s135 jump2 s76 jump9 jump14 s61 jump7 jump12 s96 s138 |
	self SubCq: 32 R: SPReg.
	self MoveR: ReceiverResultReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveR: Arg0Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveR: Arg1Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 16 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self TstCq: 7 R: Extra3Reg.
	jump1 := self JumpNonZero: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra1Reg.
	self AndCq: 1 R: Extra1Reg.
	self CmpCq: 0 R: Extra1Reg.
	jump2 := self JumpZero: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self ArithmeticShiftRightCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self TstCq: 2 R: Extra3Reg.
	jump3 := self JumpZero: 0.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 24 r: SPReg.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 24 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: Extra2Reg.
	self MoveR: Extra2Reg R: ClassReg.
	self AndCq: 16r3FFFFF R: ClassReg.
	self CmpCq: 36 R: ClassReg.
	jump4 := self JumpZero: 0.
	self LogicalShiftRightCq: 24 R: Extra2Reg.
	self AndCq: 31 R: Extra2Reg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMb: 7 r: Extra3Reg R: ClassReg.
	self AndCq: 255 R: ClassReg.
	self CmpCq: 255 R: ClassReg.
	jump5 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: -8 r: Extra3Reg R: ClassReg.
	self LogicalShiftLeftCq: 8 R: ClassReg.
	self LogicalShiftRightCq: 8 R: ClassReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 5 R: Extra2Reg.
	jump6 := self JumpAbove: 0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 16 R: Extra2Reg.
	jump6 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 3 R: ClassReg.
	self MoveR: Extra2Reg R: SendNumArgsReg.
	self AndCq: 7 R: SendNumArgsReg.
	self SubR: SendNumArgsReg R: ClassReg.
	self MoveR: ClassReg R: SendNumArgsReg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 12 R: Extra2Reg.
	jump6 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 2 R: ClassReg.
	self MoveR: Extra2Reg R: SendNumArgsReg.
	self AndCq: 3 R: SendNumArgsReg.
	self SubR: SendNumArgsReg R: ClassReg.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 10 R: Extra2Reg.
	jump6 := self JumpBelow: 0.
	self LogicalShiftLeftCq: 1 R: ClassReg.
	self MoveR: Extra2Reg R: SendNumArgsReg.
	self AndCq: 1 R: SendNumArgsReg.
	self SubR: SendNumArgsReg R: ClassReg.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra2Reg.
	jump6 := self JumpNonZero: 0.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	s61 := 0.
	self MoveCq: s61 R: ClassReg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	jump10 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra2Reg.
	jump10 := self JumpBelow: 0.
	self MoveR: ClassReg R: SendNumArgsReg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self CmpCq: 2 R: Extra2Reg.
	jump10 := self JumpNonZero: 0.
	self MoveR: ClassReg R: SendNumArgsReg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	s76 := 0.
	self MoveCq: s76 R: Extra0Reg.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self CmpCq: 2 R: Extra2Reg.
	jump10 := self JumpAboveOrEqual: 0.
	self MoveR: ClassReg R: Extra0Reg.
	self MoveR: ClassReg R: SendNumArgsReg.
	jump9 := self Jump: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: SendNumArgsReg.
	self AndCq: 16r3FFFFF R: SendNumArgsReg.
	self CmpCq: 31 R: SendNumArgsReg.
	jump10 := self JumpAbove: 0.
	self CmpCq: 31 R: SendNumArgsReg.
	jump8 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: SendNumArgsReg.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self CmpCq: 8 R: SendNumArgsReg.
	jump8 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: SendNumArgsReg.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self MoveR: SendNumArgsReg R: Extra0Reg.
	self LogicalShiftRightCq: 10 R: Extra0Reg.
	s96 := objectMemory hiddenRootsObject.
	self LogicalShiftLeftCq: 3 R: Extra0Reg.
	self AddCq: s96 R: Extra0Reg.
	self MoveM64: 8 r: Extra0Reg R: Extra0Reg.
	self genMoveConstant: objectMemory nilObject R: Extra1Reg.
	self CmpR: Extra1Reg R: Extra0Reg.
	jump8 := self JumpNonZero: 0.
	self genMoveConstant: objectMemory nilObject R: Extra1Reg.
	jump10 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self AndCq: 1023 R: SendNumArgsReg.
	self LogicalShiftLeftCq: 3 R: SendNumArgsReg.
	self AddR: SendNumArgsReg R: Extra0Reg.
	self MoveM64: 8 r: Extra0Reg R: Extra1Reg.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	self MoveR: Extra1Reg R: SendNumArgsReg.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	self MoveM64: 24 r: SendNumArgsReg R: Extra1Reg.
	self ArithmeticShiftRightCq: 3 R: Extra1Reg.
	self AndCq: 16rFFFF R: Extra1Reg.
	self MoveR: Extra1Reg R: Extra0Reg.
	self MoveR: ClassReg R: SendNumArgsReg.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump9 jmpTarget: currentBlock.
	self SubR: Extra0Reg R: SendNumArgsReg.
	self CmpCq: 24 R: Extra2Reg.
	jump9 := self JumpAboveOrEqual: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpCq: 1 R: Extra3Reg.
	jump7 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self CmpR: SendNumArgsReg R: Extra3Reg.
	jump6 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AddR: Extra0Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self CmpCq: 5 R: Extra2Reg.
	jump5 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra1Reg.
	self AndCq: 7 R: Extra1Reg.
	self CmpCq: 0 R: Extra1Reg.
	jump10 := self JumpNonZero: 0.
	s135 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra1Reg.
	self AndCq: s135 R: Extra1Reg.
	s138 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s138 R: Extra1Reg.
	jump8 := self JumpNonZero: 0.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra1Reg.
	self AndCq: 7 R: Extra1Reg.
	self CmpCq: 0 R: Extra1Reg.
	jump11 := self JumpNonZero: 0.
	s143 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra1Reg.
	self AndCq: s143 R: Extra1Reg.
	s146 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s146 R: Extra1Reg.
	jump12 := self JumpNonZero: 0.
	s148 := objectMemory getMemoryMap getNewSpaceStart.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra1Reg.
	self CmpCq: s148 R: Extra1Reg.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: Extra1Reg.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: Extra1Reg.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: Extra1Reg.
	jump13 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: Extra1Reg.
	self LogicalShiftRightCq: 29 R: Extra1Reg.
	self AndCq: 1 R: Extra1Reg.
	self CmpCq: 0 R: Extra1Reg.
	jump14 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	jump15 := self Jump: 0.
	currentBlock := self Label.
	jump12 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump11 jmpTarget: currentBlock.
	jump13 jmpTarget: currentBlock.
	jump14 jmpTarget: currentBlock.
	jump15 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM64: 0 r: Extra3Reg R: Extra1Reg.
	self LogicalShiftRightCq: 29 R: Extra1Reg.
	self AndCq: 1 R: Extra1Reg.
	self CmpCq: 0 R: Extra1Reg.
	jump15 := self JumpZero: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self MoveMw: 0 r: SPReg R: Extra4Reg.
	self MoveR: Extra3Reg M64: 8 r: Extra4Reg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ReceiverResultReg.
	self AddCq: 32 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump15 jmpTarget: currentBlock.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self TstCq: 7 R: Extra3Reg.
	jump15 := self JumpZero: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self MoveMw: 0 r: SPReg R: Extra4Reg.
	self MoveR: Extra3Reg M64: 8 r: Extra4Reg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ReceiverResultReg.
	self AddCq: 32 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump15 jmpTarget: currentBlock.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self CmpCq: 16r20000000000 R: Extra3Reg.
	jump15 := self JumpBelow: 0.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self CmpCq: 16r20000000000 R: Extra3Reg.
	jump14 := self JumpBelow: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self MoveMw: 0 r: SPReg R: Extra4Reg.
	self MoveR: Extra3Reg M64: 8 r: Extra4Reg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ReceiverResultReg.
	self AddCq: 32 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump14 jmpTarget: currentBlock.
	self genMoveConstant: objectMemory nilObject R: Extra1Reg.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self CmpR: Extra1Reg R: Extra3Reg.
	jump14 := self JumpBelow: 0.
	s185 := objectMemory trueObject.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self CmpCq: s185 R: Extra3Reg.
	jump13 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self MoveMw: 0 r: SPReg R: Extra4Reg.
	self MoveR: Extra3Reg M64: 8 r: Extra4Reg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ReceiverResultReg.
	self AddCq: 32 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump14 jmpTarget: currentBlock.
	jump13 jmpTarget: currentBlock.
	s192 := objectMemory getMemoryMap getNewSpaceStart.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self CmpCq: s192 R: Extra3Reg.
	jump13 := self JumpBelow: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self MoveMw: 0 r: SPReg R: Extra4Reg.
	self MoveR: Extra3Reg M64: 8 r: Extra4Reg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ReceiverResultReg.
	self AddCq: 32 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump13 jmpTarget: currentBlock.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self MoveMw: 0 r: SPReg R: Extra4Reg.
	self MoveR: Extra3Reg M64: 8 r: Extra4Reg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ReceiverResultReg.
	self AddCq: 32 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump15 jmpTarget: currentBlock.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self MoveMw: 0 r: SPReg R: Extra4Reg.
	self MoveR: Extra3Reg M64: 8 r: Extra4Reg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ReceiverResultReg.
	self AddCq: 32 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 16 R: Extra2Reg.
	jump5 := self JumpBelow: 0.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self TstCq: 1 R: Extra3Reg.
	jump15 := self JumpZero: 0.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self ArithmeticShiftRightCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 24 r: SPReg.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self CmpCq: 0 R: Extra3Reg.
	jump13 := self JumpBelow: 0.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self CmpCq: 255 R: Extra3Reg.
	jump14 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self MoveMw: 0 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self AddCq:  -1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self MoveR: Extra3Reg Mb: 8 r: Extra4Reg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ReceiverResultReg.
	self AddCq: 32 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 12 R: Extra2Reg.
	jump5 := self JumpBelow: 0.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self TstCq: 1 R: Extra3Reg.
	jump11 := self JumpZero: 0.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self ArithmeticShiftRightCq: 3 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 24 r: SPReg.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self CmpCq: 0 R: Extra3Reg.
	jump8 := self JumpBelow: 0.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self CmpCq: 16rFFFF R: Extra3Reg.
	jump10 := self JumpAbove: 0.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self SubCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 8 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 1 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 8 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveMw: 8 r: SPReg R: Extra4Reg.
	self AddR: Extra4Reg R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 0 r: SPReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: Extra1Reg.
	self AddCq: 8 R: Extra1Reg.
	self MoveR: Extra1Reg R: ClassReg.
	self AndCq: 2 R: ClassReg.
	self CmpCq: 0 R: ClassReg.
	jump12 := self JumpNonZero: 0.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveM32: 8 r: Extra3Reg R: ClassReg.
	self AndCq: 16rFFFFFFFF R: ClassReg.
	self AndCq: 16rFFFF0000 R: ClassReg.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self OrR: Extra3Reg R: ClassReg.
	self MoveMw: 0 r: SPReg R: Extra3Reg.
	self MoveR: ClassReg M32: 8 r: Extra3Reg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ReceiverResultReg.
	self AddCq: 32 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump12 jmpTarget: currentBlock.
	self MoveM32: -2 r: Extra1Reg R: ClassReg.
	self AndCq: 16rFFFFFFFF R: ClassReg.
	self AndCq: 16rFFFF R: ClassReg.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self LogicalShiftLeftCq: 16 R: Extra3Reg.
	self MoveR: Extra3Reg Mw: 24 r: SPReg.
	self MoveMw: 24 r: SPReg R: Extra3Reg.
	self OrR: Extra3Reg R: ClassReg.
	self MoveR: ClassReg M32: -2 r: Extra1Reg.
	self MoveMw: 16 r: SPReg R: Extra3Reg.
	self MoveR: Extra3Reg R: ReceiverResultReg.
	self AddCq: 32 R: SPReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self CmpCq: 9 R: Extra2Reg.
	jump5 := self JumpNonZero: 0.
	currentBlock := self Label.
	jump10 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump14 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump11 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump15 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump9 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump13 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self AddCq: 32 R: SPReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PrimitiveSubtract [
	"AutoGenerated by Druid"

	| jump1 jump2 jump3 currentBlock |
	self MoveR: ReceiverResultReg R: ClassReg.
	self MoveR: Arg0Reg R: SendNumArgsReg.
	self TstCq: 1 R: ClassReg.
	jump1 := self JumpZero: 0.
	self TstCq: 1 R: SendNumArgsReg.
	jump2 := self JumpZero: 0.
	self AddCq:  -1 R: SendNumArgsReg.
	self SubR: SendNumArgsReg R: ClassReg.
	jump3 := self JumpOverflow: 0.
	self MoveR: ClassReg R: ReceiverResultReg.
	self genPrimReturn.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushConstantFalseBytecode [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := objectMemory falseObject.
	self ssPushConstant: s2.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushConstantNilBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: objectMemory nilObject R: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushConstantOneBytecode [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := ConstOne.
	self ssPushConstant: s2.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushConstantTrueBytecode [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := objectMemory trueObject.
	self ssPushConstant: s2.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushConstantZeroBytecode [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := ConstZero.
	self ssPushConstant: s2.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode0 [
	"AutoGenerated by Druid"

	| t0 s4 currentBlock live s3 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 << 3.
	self AddCq: s4 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode1 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 1.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode10 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 10.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode11 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 11.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode12 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 12.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode13 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 13.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode14 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 14.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode15 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 15.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode16 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 16.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode17 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 17.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode18 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 18.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode19 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 19.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode2 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 2.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode20 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 20.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode21 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 21.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode22 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 22.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode23 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 23.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode24 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 24.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode25 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 25.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode26 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 26.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode27 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 27.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode28 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 28.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode29 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 29.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode3 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 3.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode30 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 30.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode31 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 31.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode4 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 4.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode5 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 5.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode6 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 6.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode7 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 7.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode8 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 8.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralConstantBytecode9 [
	"AutoGenerated by Druid"

	| s3 t0 s4 currentBlock live s5 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 9.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode0 [
	"AutoGenerated by Druid"

	| jump1 s3 s28 t1 jump3 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 << 3.
	self AddCq: s4 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s28 := ValueIndex.
	s29 := s28 << 3.
	self AddCq: s29 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode1 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 1.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode10 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 10.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode11 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 11.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode12 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 12.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode13 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 13.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode14 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 14.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode15 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 15.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode2 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 2.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode3 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 3.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode4 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 4.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode5 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 5.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode6 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 6.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode7 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 7.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode8 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 8.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushLiteralVariable16CasesBytecode9 [
	"AutoGenerated by Druid"

	| jump1 s3 t1 jump3 s5 s30 currentBlock t0 jump2 s4 s29 b233 live jump4 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: methodObj R: t0.
	s3 := LiteralStart.
	s4 := s3 + 9.
	s5 := s4 << 3.
	self AddCq: s5 R: t0.
	self MoveM64: 8 r: t0 R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	self MoveM64: 0 r: t0 R: t1.
	self AndCq: 16r3FFFF7 R: t1.
	self CmpCq: 0 R: t1.
	jump1 := self JumpNonZero: 0.
	self MoveM64: 8 r: t0 R: t1.
	b233 := self Label.
	self MoveR: t1 R: t0.
	self AndCq: 7 R: t0.
	self CmpCq: 0 R: t0.
	jump2 := self JumpNonZero: 0.
	self MoveM64: 0 r: t1 R: t0.
	self AndCq: 16r3FFFF7 R: t0.
	self CmpCq: 0 R: t0.
	jump3 := self JumpNonZero: 0.
	self MoveM64: 8 r: t1 R: t0.
	self MoveR: t0 R: t1.
	jump4 := self Jump: b233.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	self MoveR: t1 R: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s29 := ValueIndex.
	s30 := s29 << 3.
	self AddCq: s30 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushNewArrayBytecode [
	"AutoGenerated by Druid"

	| s6 s50 s46 s4 s22 s31 s29 s38 b109 s2 s20 currentBlock s36 s42 t1 s7 jump1 s34 s47 s17 s10 live s56 s45 s3 s28 s30 s21 t2 s52 s8 jump2 s35 t0 s11 |
	live := 0.
	s2 := byte1.
	s3 := s2 bitAnd: 127.
	s4 := ClassArrayCompactIndex.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveAw: objectMemory freeStartAddress R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	s3 < 1 ifTrue: [
		| jump1 jump2 b109 |
		s7 := 16.
		s8 := s7.
		self MoveAw: objectMemory freeStartAddress R: t1.
		self AddCq: s8 R: t1.
		s17 := objectMemory getScavengeThreshold.
		self CmpCq: s17 R: t1.
		jump1 := self JumpBelowOrEqual: 0.
		jump2 := self Jump: 0.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		s20 := s3 << 56.
		s21 := s20 + s4.
		s22 := s21 + 33554432.
		self MoveCq: s22 R: t1.
		self MoveR: t1 M64: 0 r: t0.
		self MoveAw: objectMemory freeStartAddress R: t1.
		self AddCq: s8 R: t1.
		self MoveR: t1 Aw: objectMemory freeStartAddress.
		s2 > 127 ifTrue: [
			| b81 |
			s29 := 0.
			s30 := s3 - 1.
			s31 := s29.
			b81 := self Label.
			[ ((s31<=s30)) ] whileTrue: [
				s35 := s3 - s31.
				s36 := s35 - 1.
				(self ssValue: 0) copyToReg: t1.
				s38 := s36 << 3.
				self MoveR: t0 R: t2.
				self AddCq: s38 R: t2.
				self MoveR: t1 M64: 8 r: t2.
				s42 := s31 + 1.
				s31 := s42 ].
			self ssPushRegister: t1.
			^ 0 ].
		s45 := 0.
		s46 := s3 - 1.
		s47 := s45.
		b109 := self Label.
		[ ((s47<=s46)) ] whileTrue: [
			self genMoveConstant: objectMemory nilObject R: t2.
			s52 := s47 << 3.
			self MoveR: t0 R: t1.
			self AddCq: s52 R: t1.
			self MoveR: t2 M64: 8 r: t1.
			s56 := s47 + 1.
			s47 := s56 ].
		self ssPushRegister: t1.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		^ 0 ].
	s10 := s3 << 3.
	s11 := s10 + 8.
	s8 := s11.
	self MoveAw: objectMemory freeStartAddress R: t1.
	self AddCq: s8 R: t1.
	s17 := objectMemory getScavengeThreshold.
	self CmpCq: s17 R: t1.
	jump2 := self JumpBelowOrEqual: 0.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	s20 := s3 << 56.
	s21 := s20 + s4.
	s22 := s21 + 33554432.
	self MoveCq: s22 R: t1.
	self MoveR: t1 M64: 0 r: t0.
	self MoveAw: objectMemory freeStartAddress R: t1.
	self AddCq: s8 R: t1.
	self MoveR: t1 Aw: objectMemory freeStartAddress.
	s2 > 127 ifTrue: [
		| b81 |
		s29 := 0.
		s30 := s3 - 1.
		s31 := s29.
		b81 := self Label.
		[ ((s31<=s30)) ] whileTrue: [
			s35 := s3 - s31.
			s36 := s35 - 1.
			(self ssValue: 0) copyToReg: t1.
			s38 := s36 << 3.
			self MoveR: t0 R: t2.
			self AddCq: s38 R: t2.
			self MoveR: t1 M64: 8 r: t2.
			s42 := s31 + 1.
			s31 := s42 ].
		self ssPushRegister: t1.
		^ 0 ].
	s45 := 0.
	s46 := s3 - 1.
	s47 := s45.
	b109 := self Label.
	[ ((s47<=s46)) ] whileTrue: [
		self genMoveConstant: objectMemory nilObject R: t2.
		s52 := s47 << 3.
		self MoveR: t0 R: t1.
		self AddCq: s52 R: t1.
		self MoveR: t2 M64: 8 r: t1.
		s56 := s47 + 1.
		s47 := s56 ].
	self ssPushRegister: t1.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverBytecode [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode0 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode1 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 16.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode10 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 88.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode11 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 96.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode12 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 104.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode13 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 112.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode14 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 120.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode15 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 128.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode2 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 24.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode3 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 32.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode4 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 40.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode5 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 48.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode6 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 56.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode7 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 64.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode8 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 72.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushReceiverVariableBytecode9 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self ssPushBase: t0 offset: 80.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushRemoteTempLongBytecode [
	"AutoGenerated by Druid"

	| t0 s32 s4 s2 currentBlock t1 live s5 |
	live := 0.
	s2 := byte1.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: byte2) copyToReg: t0.
	s4 := TempVectReadBarrier.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	s4 ifTrue: [
		| jump3 jump1 b199 jump4 jump2 |
		self MoveM64: 0 r: t0 R: t1.
		self AndCq: 16r3FFFF7 R: t1.
		self CmpCq: 0 R: t1.
		jump1 := self JumpNonZero: 0.
		self MoveM64: 8 r: t0 R: t1.
		b199 := self Label.
		self MoveR: t1 R: t0.
		self AndCq: 7 R: t0.
		self CmpCq: 0 R: t0.
		jump2 := self JumpNonZero: 0.
		self MoveM64: 0 r: t1 R: t0.
		self AndCq: 16r3FFFF7 R: t0.
		self CmpCq: 0 R: t0.
		jump3 := self JumpNonZero: 0.
		self MoveM64: 8 r: t1 R: t0.
		self MoveR: t0 R: t1.
		jump4 := self Jump: b199.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		jump3 jmpTarget: currentBlock.
		self MoveR: t1 R: t0.
		jump3 := self Jump: 0.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		s32 := s2 << 3.
		self AddCq: s32 R: t0.
		self ssPushBase: t0 offset: 8.
		^ 0 ].
	s32 := s2 << 3.
	self AddCq: s32 R: t0.
	self ssPushBase: t0 offset: 8.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushTemporaryVariableBytecode0 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 0) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushTemporaryVariableBytecode1 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 1) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushTemporaryVariableBytecode10 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 10) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushTemporaryVariableBytecode11 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 11) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushTemporaryVariableBytecode2 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 2) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushTemporaryVariableBytecode3 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 3) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushTemporaryVariableBytecode4 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 4) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushTemporaryVariableBytecode5 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 5) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushTemporaryVariableBytecode6 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 6) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushTemporaryVariableBytecode7 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 7) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushTemporaryVariableBytecode8 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 8) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_PushTemporaryVariableBytecode9 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: 9) copyToReg: t0.
	self ssPushRegister: t0.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ReturnFalse [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := objectMemory falseObject.
	self MoveCq: s2 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ReturnNil [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: objectMemory nilObject R: t0.
	self MoveR: t0 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ReturnNilFromBlock [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self genMoveConstant: objectMemory nilObject R: t0.
	self MoveR: t0 R: ReceiverResultReg.
	self genBlockReturn.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ReturnReceiver [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	self MoveR: t0 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ReturnTopFromBlock [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	self MoveR: t0 R: ReceiverResultReg.
	self genBlockReturn.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ReturnTopFromMethod [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	self MoveR: t0 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ReturnTrue [
	"AutoGenerated by Druid"

	| live currentBlock s2 |
	live := 0.
	s2 := objectMemory trueObject.
	self MoveCq: s2 R: ReceiverResultReg.
	self genUpArrowReturn.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode0 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 0
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode1 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 1
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode10 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 10
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode11 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 11
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode12 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 12
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode13 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 13
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode14 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 14
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode15 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 15
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode2 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 2
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode3 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 3
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode4 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 4
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode5 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 5
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode6 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 6
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode7 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 7
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode8 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 8
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector0ArgsBytecode9 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 0.
	self
		genMarshalledSendNoPush: 9
		numArgs: 0
		sendTable: ordinarySendTrampolines.
	self ssPop: 1 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode0 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 0
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode1 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 1
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode10 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 10
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode11 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 11
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode12 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 12
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode13 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 13
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode14 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 14
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode15 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 15
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode2 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 2
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode3 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 3
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode4 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 4
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode5 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 5
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode6 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 6
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode7 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 7
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode8 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 8
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector1ArgBytecode9 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 1.
	self
		genMarshalledSendNoPush: 9
		numArgs: 1
		sendTable: ordinarySendTrampolines.
	self ssPop: 2 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode0 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 0
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode1 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 1
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode10 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 10
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode11 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 11
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode12 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 12
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode13 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 13
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode14 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 14
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode15 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 15
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode2 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 2
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode3 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 3
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode4 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 4
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode5 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 5
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode6 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 6
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode7 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 7
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode8 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 8
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_SendLiteralSelector2ArgsBytecode9 [
	"AutoGenerated by Druid"

	| live currentBlock |
	live := 0.
	self marshallSendArgumentsNoPush: 2.
	self
		genMarshalledSendNoPush: 9
		numArgs: 2
		sendTable: ordinarySendTrampolines.
	self ssPop: 3 popSpilled: false.
	self ssPushConstant: ReceiverResultReg.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpFalse0 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 jump3 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory falseObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 2.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory trueObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpFalse1 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 jump3 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory falseObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 3.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory trueObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpFalse2 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 jump3 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory falseObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 4.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory trueObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpFalse3 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 jump3 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory falseObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 5.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory trueObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpFalse4 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 jump3 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory falseObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 6.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory trueObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpFalse5 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 jump3 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory falseObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 7.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory trueObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpFalse6 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 jump3 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory falseObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 8.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory trueObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpFalse7 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 jump3 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory falseObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 9.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory trueObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpTrue0 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 jump3 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory trueObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 2.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory falseObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpTrue1 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 jump3 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory trueObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 3.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory falseObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpTrue2 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 jump3 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory trueObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 4.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory falseObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpTrue3 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 jump3 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory trueObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 5.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory falseObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpTrue4 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 jump3 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory trueObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 6.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory falseObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpTrue5 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 jump3 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory trueObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 7.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory falseObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpTrue6 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 jump3 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory trueObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 8.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory falseObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortConditionalJumpTrue7 [
	"AutoGenerated by Druid"

	| jump1 s10 s8 s5 s2 jump3 currentBlock s12 t0 jump2 live s9 |
	live := 0.
	self annotateBytecode: self Label.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssPop: 1 popSpilled: true.
	s5 := objectMemory trueObject.
	self ssFlushStack.
	self CmpCq: s5 R: t0.
	jump1 := self JumpNonZero: 0.
	s8 := bytecodePC.
	s9 := s8 + 9.
	self Jump: (self ensureFixupAt: s9).
	deadCode := true.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	s12 := objectMemory falseObject.
	self CmpCq: s12 R: t0.
	jump1 := self JumpNonZero: 0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t0 R: TempReg.
	self CallRT: ceSendMustBeBooleanTrampoline.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortUnconditionalJump0 [
	"AutoGenerated by Druid"

	| s5 s2 currentBlock live s3 |
	live := 0.
	s2 := bytecodePC.
	s3 := s2 + 2.
	self ssFlushStack.
	self Jump: (self ensureFixupAt: s3).
	deadCode := true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortUnconditionalJump1 [
	"AutoGenerated by Druid"

	| s5 s2 currentBlock live s3 |
	live := 0.
	s2 := bytecodePC.
	s3 := s2 + 3.
	self ssFlushStack.
	self Jump: (self ensureFixupAt: s3).
	deadCode := true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortUnconditionalJump2 [
	"AutoGenerated by Druid"

	| s5 s2 currentBlock live s3 |
	live := 0.
	s2 := bytecodePC.
	s3 := s2 + 4.
	self ssFlushStack.
	self Jump: (self ensureFixupAt: s3).
	deadCode := true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortUnconditionalJump3 [
	"AutoGenerated by Druid"

	| s5 s2 currentBlock live s3 |
	live := 0.
	s2 := bytecodePC.
	s3 := s2 + 5.
	self ssFlushStack.
	self Jump: (self ensureFixupAt: s3).
	deadCode := true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortUnconditionalJump4 [
	"AutoGenerated by Druid"

	| s5 s2 currentBlock live s3 |
	live := 0.
	s2 := bytecodePC.
	s3 := s2 + 6.
	self ssFlushStack.
	self Jump: (self ensureFixupAt: s3).
	deadCode := true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortUnconditionalJump5 [
	"AutoGenerated by Druid"

	| s5 s2 currentBlock live s3 |
	live := 0.
	s2 := bytecodePC.
	s3 := s2 + 7.
	self ssFlushStack.
	self Jump: (self ensureFixupAt: s3).
	deadCode := true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortUnconditionalJump6 [
	"AutoGenerated by Druid"

	| s5 s2 currentBlock live s3 |
	live := 0.
	s2 := bytecodePC.
	s3 := s2 + 8.
	self ssFlushStack.
	self Jump: (self ensureFixupAt: s3).
	deadCode := true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_ShortUnconditionalJump7 [
	"AutoGenerated by Druid"

	| s5 s2 currentBlock live s3 |
	live := 0.
	s2 := bytecodePC.
	s3 := s2 + 9.
	self ssFlushStack.
	self Jump: (self ensureFixupAt: s3).
	deadCode := true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopReceiverVariableBytecode0 [
	"AutoGenerated by Druid"

	| jump5 s24 s16 jump3 s29 jump8 jump1 t1 s2 currentBlock s19 s27 jump6 s56 live jump4 jump2 t2 s52 jump7 t0 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1 popSpilled: true.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s16 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s16 R: t2.
	s19 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s19 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	s24 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s24 R: t2.
	s27 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s27 R: t2.
	jump5 := self JumpNonZero: 0.
	s29 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s29 R: t1.
	jump6 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpZero: 0.
	self MoveR: t1 M64: 8 r: t0.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpZero: 0.
	self MoveR: t1 M64: 8 r: t0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 16r20000000000 R: t0.
	jump7 := self JumpLess: 0.
	self CmpCq: 16r20000000000 R: t1.
	jump4 := self JumpLess: 0.
	self MoveR: t1 M64: 8 r: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t1.
	jump4 := self JumpBelow: 0.
	s52 := objectMemory trueObject.
	self CmpCq: s52 R: t1.
	jump1 := self JumpAbove: 0.
	self MoveR: t1 M64: 8 r: t0.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	s56 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s56 R: t1.
	jump1 := self JumpBelow: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	self MoveR: t1 M64: 8 r: t0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 8 r: t0.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: t1 M64: 8 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopReceiverVariableBytecode1 [
	"AutoGenerated by Druid"

	| jump5 s24 s16 jump3 s29 jump8 jump1 t1 s2 currentBlock s19 s27 jump6 s56 live jump4 jump2 t2 s52 jump7 t0 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1 popSpilled: true.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s16 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s16 R: t2.
	s19 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s19 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	s24 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s24 R: t2.
	s27 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s27 R: t2.
	jump5 := self JumpNonZero: 0.
	s29 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s29 R: t1.
	jump6 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpZero: 0.
	self MoveR: t1 M64: 16 r: t0.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpZero: 0.
	self MoveR: t1 M64: 16 r: t0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 16r20000000000 R: t0.
	jump7 := self JumpLess: 0.
	self CmpCq: 16r20000000000 R: t1.
	jump4 := self JumpLess: 0.
	self MoveR: t1 M64: 16 r: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t1.
	jump4 := self JumpBelow: 0.
	s52 := objectMemory trueObject.
	self CmpCq: s52 R: t1.
	jump1 := self JumpAbove: 0.
	self MoveR: t1 M64: 16 r: t0.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	s56 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s56 R: t1.
	jump1 := self JumpBelow: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	self MoveR: t1 M64: 16 r: t0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 16 r: t0.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: t1 M64: 16 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopReceiverVariableBytecode2 [
	"AutoGenerated by Druid"

	| jump5 s24 s16 jump3 s29 jump8 jump1 t1 s2 currentBlock s19 s27 jump6 s56 live jump4 jump2 t2 s52 jump7 t0 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1 popSpilled: true.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s16 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s16 R: t2.
	s19 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s19 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	s24 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s24 R: t2.
	s27 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s27 R: t2.
	jump5 := self JumpNonZero: 0.
	s29 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s29 R: t1.
	jump6 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpZero: 0.
	self MoveR: t1 M64: 24 r: t0.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpZero: 0.
	self MoveR: t1 M64: 24 r: t0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 16r20000000000 R: t0.
	jump7 := self JumpLess: 0.
	self CmpCq: 16r20000000000 R: t1.
	jump4 := self JumpLess: 0.
	self MoveR: t1 M64: 24 r: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t1.
	jump4 := self JumpBelow: 0.
	s52 := objectMemory trueObject.
	self CmpCq: s52 R: t1.
	jump1 := self JumpAbove: 0.
	self MoveR: t1 M64: 24 r: t0.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	s56 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s56 R: t1.
	jump1 := self JumpBelow: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	self MoveR: t1 M64: 24 r: t0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 24 r: t0.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: t1 M64: 24 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopReceiverVariableBytecode3 [
	"AutoGenerated by Druid"

	| jump5 s24 s16 jump3 s29 jump8 jump1 t1 s2 currentBlock s19 s27 jump6 s56 live jump4 jump2 t2 s52 jump7 t0 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1 popSpilled: true.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s16 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s16 R: t2.
	s19 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s19 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	s24 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s24 R: t2.
	s27 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s27 R: t2.
	jump5 := self JumpNonZero: 0.
	s29 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s29 R: t1.
	jump6 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpZero: 0.
	self MoveR: t1 M64: 32 r: t0.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpZero: 0.
	self MoveR: t1 M64: 32 r: t0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 16r20000000000 R: t0.
	jump7 := self JumpLess: 0.
	self CmpCq: 16r20000000000 R: t1.
	jump4 := self JumpLess: 0.
	self MoveR: t1 M64: 32 r: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t1.
	jump4 := self JumpBelow: 0.
	s52 := objectMemory trueObject.
	self CmpCq: s52 R: t1.
	jump1 := self JumpAbove: 0.
	self MoveR: t1 M64: 32 r: t0.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	s56 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s56 R: t1.
	jump1 := self JumpBelow: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	self MoveR: t1 M64: 32 r: t0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 32 r: t0.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: t1 M64: 32 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopReceiverVariableBytecode4 [
	"AutoGenerated by Druid"

	| jump5 s24 s16 jump3 s29 jump8 jump1 t1 s2 currentBlock s19 s27 jump6 s56 live jump4 jump2 t2 s52 jump7 t0 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1 popSpilled: true.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s16 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s16 R: t2.
	s19 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s19 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	s24 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s24 R: t2.
	s27 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s27 R: t2.
	jump5 := self JumpNonZero: 0.
	s29 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s29 R: t1.
	jump6 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpZero: 0.
	self MoveR: t1 M64: 40 r: t0.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpZero: 0.
	self MoveR: t1 M64: 40 r: t0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 16r20000000000 R: t0.
	jump7 := self JumpLess: 0.
	self CmpCq: 16r20000000000 R: t1.
	jump4 := self JumpLess: 0.
	self MoveR: t1 M64: 40 r: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t1.
	jump4 := self JumpBelow: 0.
	s52 := objectMemory trueObject.
	self CmpCq: s52 R: t1.
	jump1 := self JumpAbove: 0.
	self MoveR: t1 M64: 40 r: t0.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	s56 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s56 R: t1.
	jump1 := self JumpBelow: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	self MoveR: t1 M64: 40 r: t0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 40 r: t0.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: t1 M64: 40 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopReceiverVariableBytecode5 [
	"AutoGenerated by Druid"

	| jump5 s24 s16 jump3 s29 jump8 jump1 t1 s2 currentBlock s19 s27 jump6 s56 live jump4 jump2 t2 s52 jump7 t0 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1 popSpilled: true.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s16 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s16 R: t2.
	s19 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s19 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	s24 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s24 R: t2.
	s27 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s27 R: t2.
	jump5 := self JumpNonZero: 0.
	s29 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s29 R: t1.
	jump6 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpZero: 0.
	self MoveR: t1 M64: 48 r: t0.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpZero: 0.
	self MoveR: t1 M64: 48 r: t0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 16r20000000000 R: t0.
	jump7 := self JumpLess: 0.
	self CmpCq: 16r20000000000 R: t1.
	jump4 := self JumpLess: 0.
	self MoveR: t1 M64: 48 r: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t1.
	jump4 := self JumpBelow: 0.
	s52 := objectMemory trueObject.
	self CmpCq: s52 R: t1.
	jump1 := self JumpAbove: 0.
	self MoveR: t1 M64: 48 r: t0.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	s56 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s56 R: t1.
	jump1 := self JumpBelow: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	self MoveR: t1 M64: 48 r: t0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 48 r: t0.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: t1 M64: 48 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopReceiverVariableBytecode6 [
	"AutoGenerated by Druid"

	| jump5 s24 s16 jump3 s29 jump8 jump1 t1 s2 currentBlock s19 s27 jump6 s56 live jump4 jump2 t2 s52 jump7 t0 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1 popSpilled: true.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s16 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s16 R: t2.
	s19 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s19 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	s24 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s24 R: t2.
	s27 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s27 R: t2.
	jump5 := self JumpNonZero: 0.
	s29 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s29 R: t1.
	jump6 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpZero: 0.
	self MoveR: t1 M64: 56 r: t0.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpZero: 0.
	self MoveR: t1 M64: 56 r: t0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 16r20000000000 R: t0.
	jump7 := self JumpLess: 0.
	self CmpCq: 16r20000000000 R: t1.
	jump4 := self JumpLess: 0.
	self MoveR: t1 M64: 56 r: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t1.
	jump4 := self JumpBelow: 0.
	s52 := objectMemory trueObject.
	self CmpCq: s52 R: t1.
	jump1 := self JumpAbove: 0.
	self MoveR: t1 M64: 56 r: t0.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	s56 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s56 R: t1.
	jump1 := self JumpBelow: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	self MoveR: t1 M64: 56 r: t0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 56 r: t0.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: t1 M64: 56 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopReceiverVariableBytecode7 [
	"AutoGenerated by Druid"

	| jump5 s24 s16 jump3 s29 jump8 jump1 t1 s2 currentBlock s19 s27 jump6 s56 live jump4 jump2 t2 s52 jump7 t0 |
	live := 0.
	self annotateBytecode: self Label.
	self ensureReceiverResultRegContainsSelf.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	self MoveR: ReceiverResultReg R: t0.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	(self ssValue: 0) copyToReg: t1.
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 23 R: t2.
	self AndCq: 1 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpZero: 0.
	self deoptimize.
	jump2 := self Jump: 0.
	deadCode := false.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self ssPop: 1 popSpilled: true.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s16 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s16 R: t2.
	s19 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s19 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump4 := self JumpNonZero: 0.
	s24 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s24 R: t2.
	s27 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s27 R: t2.
	jump5 := self JumpNonZero: 0.
	s29 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s29 R: t1.
	jump6 := self JumpBelow: 0.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpZero: 0.
	self MoveR: t1 M64: 64 r: t0.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump7 := self JumpZero: 0.
	self MoveR: t1 M64: 64 r: t0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self CmpCq: 16r20000000000 R: t0.
	jump7 := self JumpLess: 0.
	self CmpCq: 16r20000000000 R: t1.
	jump4 := self JumpLess: 0.
	self MoveR: t1 M64: 64 r: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t1.
	jump4 := self JumpBelow: 0.
	s52 := objectMemory trueObject.
	self CmpCq: s52 R: t1.
	jump1 := self JumpAbove: 0.
	self MoveR: t1 M64: 64 r: t0.
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	s56 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s56 R: t1.
	jump1 := self JumpBelow: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	self MoveR: t1 M64: 64 r: t0.
	jump4 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	self MoveR: t1 M64: 64 r: t0.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	self MoveR: t1 M64: 64 r: t0.
	currentBlock := self Label.
	jump2 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump4 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopRemoteTempLongBytecode [
	"AutoGenerated by Druid"

	| s6 jump5 s4 jump3 jump8 jump1 t1 s2 currentBlock s42 jumpNext s7 jump6 s47 live s39 s80 jumpTrue s3 s76 t2 jump2 s52 jump7 s74 t0 s50 |
	live := 0.
	self annotateBytecode: self Label.
	self annotateBytecode: self Label.
	s4 := byte1.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: byte2) copyToReg: t0.
	s6 := TempVectReadBarrier.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	s6 ifTrue: [
		| jump1 b557 jumpNext jump6 jump3 jump8 jump5 jumpTrue jump2 jump7 jump4 |
		self MoveM64: 0 r: t0 R: t1.
		self AndCq: 16r3FFFF7 R: t1.
		self CmpCq: 0 R: t1.
		jump1 := self JumpNonZero: 0.
		self MoveM64: 8 r: t0 R: t1.
		b557 := self Label.
		self MoveR: t1 R: t0.
		self AndCq: 7 R: t0.
		self CmpCq: 0 R: t0.
		jump2 := self JumpNonZero: 0.
		self MoveM64: 0 r: t1 R: t0.
		self AndCq: 16r3FFFF7 R: t0.
		self CmpCq: 0 R: t0.
		jump3 := self JumpNonZero: 0.
		self MoveM64: 8 r: t1 R: t0.
		self MoveR: t0 R: t1.
		jump4 := self Jump: b557.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		jump3 jmpTarget: currentBlock.
		self MoveR: t1 R: t0.
		jump3 := self Jump: 0.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		(self ssValue: 0) copyToReg: t1.
		self MoveR: t0 R: t2.
		self AndCq: 7 R: t2.
		self ssFlushStack.
		self CmpCq: 0 R: t2.
		jump3 := self JumpNonZero: 0.
		s39 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveR: t0 R: t2.
		self AndCq: s39 R: t2.
		s42 := objectMemory getMemoryMap getOldSpaceMask.
		self CmpCq: s42 R: t2.
		jump1 := self JumpNonZero: 0.
		self MoveR: t1 R: t2.
		self AndCq: 7 R: t2.
		self CmpCq: 0 R: t2.
		jump2 := self JumpNonZero: 0.
		s47 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveR: t1 R: t2.
		self AndCq: s47 R: t2.
		s50 := objectMemory getMemoryMap getNewSpaceMask.
		self CmpCq: s50 R: t2.
		jump5 := self JumpNonZero: 0.
		s52 := objectMemory getMemoryMap getNewSpaceStart.
		self MoveR: t1 R: t2.
		self CmpCq: s52 R: t2.
		jumpTrue := self JumpAboveOrEqual: 0.
		self MoveCq: 0 R: t2.
		jumpNext := self Jump: 0.
		jumpTrue jmpTarget: self Label.
		self MoveCq: 1 R: t2.
		jumpNext jmpTarget: self Label.
		self CmpCq: 1 R: t2.
		jump6 := self JumpNonZero: 0.
		self MoveM64: 0 r: t0 R: t2.
		self LogicalShiftRightCq: 29 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump7 := self JumpNonZero: 0.
		self MoveR: t0 R: TempReg.
		backEnd saveAndRestoreLinkRegAround: [
			self CallRT: ceStoreCheckTrampoline ].
		jump8 := self Jump: 0.
		currentBlock := self Label.
		jump5 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		jump1 jmpTarget: currentBlock.
		jump2 jmpTarget: currentBlock.
		jump6 jmpTarget: currentBlock.
		jump7 jmpTarget: currentBlock.
		jump8 jmpTarget: currentBlock.
		self MoveM64: 0 r: t0 R: t2.
		self LogicalShiftRightCq: 29 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump8 := self JumpNonZero: 0.
		self TstCq: 7 R: t1.
		jump7 := self JumpNonZero: 0.
		self CmpCq: 16r20000000000 R: t0.
		jump6 := self JumpLess: 0.
		self CmpCq: 16r20000000000 R: t1.
		jump2 := self JumpGreaterOrEqual: 0.
		self genMoveConstant: objectMemory nilObject R: t2.
		self CmpR: t2 R: t1.
		jump1 := self JumpBelow: 0.
		s74 := objectMemory trueObject.
		self CmpCq: s74 R: t1.
		jump3 := self JumpBelowOrEqual: 0.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		s76 := objectMemory getMemoryMap getNewSpaceStart.
		self CmpCq: s76 R: t1.
		jump1 := self JumpBelow: 0.
		self MoveR: t0 R: TempReg.
		backEnd saveAndRestoreLinkRegAround: [
			self CallRT: ceStoreCheckTrampoline ].
		currentBlock := self Label.
		jump8 jmpTarget: currentBlock.
		jump7 jmpTarget: currentBlock.
		jump6 jmpTarget: currentBlock.
		jump2 jmpTarget: currentBlock.
		jump3 jmpTarget: currentBlock.
		jump1 jmpTarget: currentBlock.
		s80 := s4 << 3.
		self AddCq: s80 R: t0.
		self MoveR: t1 M64: 8 r: t0.
		self ssPop: 1 popSpilled: true.
		^ 0 ].
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump1 := self JumpNonZero: 0.
	s39 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s39 R: t2.
	s42 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s42 R: t2.
	jump3 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump2 := self JumpNonZero: 0.
	s47 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s47 R: t2.
	s50 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s50 R: t2.
	jump6 := self JumpNonZero: 0.
	s52 := objectMemory getMemoryMap getNewSpaceStart.
	self MoveR: t1 R: t2.
	self CmpCq: s52 R: t2.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump8 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump6 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump5 := self JumpNonZero: 0.
	self TstCq: 7 R: t1.
	jump8 := self JumpNonZero: 0.
	self CmpCq: 16r20000000000 R: t0.
	jump7 := self JumpLess: 0.
	self CmpCq: 16r20000000000 R: t1.
	jump2 := self JumpGreaterOrEqual: 0.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t1.
	jump3 := self JumpBelow: 0.
	s74 := objectMemory trueObject.
	self CmpCq: s74 R: t1.
	jump1 := self JumpBelowOrEqual: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s76 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s76 R: t1.
	jump3 := self JumpBelow: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	s80 := s4 << 3.
	self AddCq: s80 R: t0.
	self MoveR: t1 M64: 8 r: t0.
	self ssPop: 1 popSpilled: true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopTemporaryVariableBytecode0 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssFlushUpThroughTemporaryVariable: 0.
	self MoveR: t0 Mw: (self frameOffsetOfTemporary: 0) r: FPReg.
	self ssPop: 1 popSpilled: true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopTemporaryVariableBytecode1 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssFlushUpThroughTemporaryVariable: 1.
	self MoveR: t0 Mw: (self frameOffsetOfTemporary: 1) r: FPReg.
	self ssPop: 1 popSpilled: true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopTemporaryVariableBytecode2 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssFlushUpThroughTemporaryVariable: 2.
	self MoveR: t0 Mw: (self frameOffsetOfTemporary: 2) r: FPReg.
	self ssPop: 1 popSpilled: true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopTemporaryVariableBytecode3 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssFlushUpThroughTemporaryVariable: 3.
	self MoveR: t0 Mw: (self frameOffsetOfTemporary: 3) r: FPReg.
	self ssPop: 1 popSpilled: true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopTemporaryVariableBytecode4 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssFlushUpThroughTemporaryVariable: 4.
	self MoveR: t0 Mw: (self frameOffsetOfTemporary: 4) r: FPReg.
	self ssPop: 1 popSpilled: true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopTemporaryVariableBytecode5 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssFlushUpThroughTemporaryVariable: 5.
	self MoveR: t0 Mw: (self frameOffsetOfTemporary: 5) r: FPReg.
	self ssPop: 1 popSpilled: true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopTemporaryVariableBytecode6 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssFlushUpThroughTemporaryVariable: 6.
	self MoveR: t0 Mw: (self frameOffsetOfTemporary: 6) r: FPReg.
	self ssPop: 1 popSpilled: true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreAndPopTemporaryVariableBytecode7 [
	"AutoGenerated by Druid"

	| live currentBlock t0 |
	live := 0.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self ssValue: 0) copyToReg: t0.
	self ssFlushUpThroughTemporaryVariable: 7.
	self MoveR: t0 Mw: (self frameOffsetOfTemporary: 7) r: FPReg.
	self ssPop: 1 popSpilled: true.
	^ 0
]

{ #category : #generated }
DruidStaticTypePredictionJIT >> gen_StoreRemoteTempLongBytecode [
	"AutoGenerated by Druid"

	| s6 s79 jump5 s46 s94 jump3 s38 jump8 s2 t1 currentBlock s49 jump1 s51 jumpNext jump6 s73 live s5 s87 jumpTrue s3 t2 s85 s102 s98 s68 s91 jump2 t0 jump7 s41 |
	live := 0.
	self annotateBytecode: self Label.
	s3 := byte1.
	t0 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t0).
	(self simStackTempAt: byte2) copyToReg: t0.
	s5 := TempVectReadBarrier.
	t1 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t1).
	t2 := self
		      allocateRegNotConflictingWith: live
		      ifNone: [ ^ self unknownBytecode ].
	live := live bitOr: (self registerMaskFor: t2).
	s5 ifTrue: [
		| jump1 jumpNext jump6 jump3 jump8 jump5 jumpTrue jump2 b558 jump7 jump4 |
		self MoveM64: 0 r: t0 R: t1.
		self AndCq: 16r3FFFF7 R: t1.
		self CmpCq: 0 R: t1.
		jump1 := self JumpNonZero: 0.
		self MoveM64: 8 r: t0 R: t1.
		b558 := self Label.
		self MoveR: t1 R: t0.
		self AndCq: 7 R: t0.
		self CmpCq: 0 R: t0.
		jump2 := self JumpNonZero: 0.
		self MoveM64: 0 r: t1 R: t0.
		self AndCq: 16r3FFFF7 R: t0.
		self CmpCq: 0 R: t0.
		jump3 := self JumpNonZero: 0.
		self MoveM64: 8 r: t1 R: t0.
		self MoveR: t0 R: t1.
		jump4 := self Jump: b558.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		jump3 jmpTarget: currentBlock.
		self MoveR: t1 R: t0.
		jump3 := self Jump: 0.
		currentBlock := self Label.
		jump1 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		(self ssValue: 0) copyToReg: t1.
		self MoveR: t0 R: t2.
		self AndCq: 7 R: t2.
		self ssFlushStack.
		self CmpCq: 0 R: t2.
		jump3 := self JumpNonZero: 0.
		s38 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveR: t0 R: t2.
		self AndCq: s38 R: t2.
		s41 := objectMemory getMemoryMap getOldSpaceMask.
		self CmpCq: s41 R: t2.
		jump1 := self JumpNonZero: 0.
		self MoveR: t1 R: t2.
		self AndCq: 7 R: t2.
		self CmpCq: 0 R: t2.
		jump2 := self JumpNonZero: 0.
		s46 := objectMemory getMemoryMap getSpaceMaskToUse.
		self MoveR: t1 R: t2.
		self AndCq: s46 R: t2.
		s49 := objectMemory getMemoryMap getNewSpaceMask.
		self CmpCq: s49 R: t2.
		jump5 := self JumpNonZero: 0.
		s51 := objectMemory getMemoryMap getNewSpaceStart.
		self MoveR: t1 R: t2.
		self CmpCq: s51 R: t2.
		jumpTrue := self JumpAboveOrEqual: 0.
		self MoveCq: 0 R: t2.
		jumpNext := self Jump: 0.
		jumpTrue jmpTarget: self Label.
		self MoveCq: 1 R: t2.
		jumpNext jmpTarget: self Label.
		self CmpCq: 1 R: t2.
		jump6 := self JumpNonZero: 0.
		self MoveM64: 0 r: t0 R: t2.
		self LogicalShiftRightCq: 29 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump7 := self JumpNonZero: 0.
		self MoveR: t0 R: TempReg.
		backEnd saveAndRestoreLinkRegAround: [
			self CallRT: ceStoreCheckTrampoline ].
		jump8 := self Jump: 0.
		currentBlock := self Label.
		jump5 jmpTarget: currentBlock.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		jump1 jmpTarget: currentBlock.
		jump2 jmpTarget: currentBlock.
		jump6 jmpTarget: currentBlock.
		jump7 jmpTarget: currentBlock.
		jump8 jmpTarget: currentBlock.
		self MoveM64: 0 r: t0 R: t2.
		self LogicalShiftRightCq: 29 R: t2.
		self AndCq: 1 R: t2.
		self CmpCq: 0 R: t2.
		jump8 := self JumpZero: 0.
		s68 := s3 << 3.
		self AddCq: s68 R: t0.
		self MoveR: t1 M64: 8 r: t0.
		jump7 := self Jump: 0.
		currentBlock := self Label.
		jump8 jmpTarget: currentBlock.
		self TstCq: 7 R: t1.
		jump8 := self JumpZero: 0.
		s73 := s3 << 3.
		self AddCq: s73 R: t0.
		self MoveR: t1 M64: 8 r: t0.
		jump6 := self Jump: 0.
		currentBlock := self Label.
		jump8 jmpTarget: currentBlock.
		self CmpCq: 16r20000000000 R: t0.
		jump8 := self JumpLess: 0.
		self CmpCq: 16r20000000000 R: t1.
		jump2 := self JumpLess: 0.
		s79 := s3 << 3.
		self AddCq: s79 R: t0.
		self MoveR: t1 M64: 8 r: t0.
		jump1 := self Jump: 0.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		self genMoveConstant: objectMemory nilObject R: t2.
		self CmpR: t2 R: t1.
		jump2 := self JumpBelow: 0.
		s85 := objectMemory trueObject.
		self CmpCq: s85 R: t1.
		jump3 := self JumpAbove: 0.
		s87 := s3 << 3.
		self AddCq: s87 R: t0.
		self MoveR: t1 M64: 8 r: t0.
		jump5 := self Jump: 0.
		currentBlock := self Label.
		jump2 jmpTarget: currentBlock.
		jump3 jmpTarget: currentBlock.
		s91 := objectMemory getMemoryMap getNewSpaceStart.
		self CmpCq: s91 R: t1.
		jump3 := self JumpBelow: 0.
		self MoveR: t0 R: TempReg.
		backEnd saveAndRestoreLinkRegAround: [
			self CallRT: ceStoreCheckTrampoline ].
		s94 := s3 << 3.
		self AddCq: s94 R: t0.
		self MoveR: t1 M64: 8 r: t0.
		jump2 := self Jump: 0.
		currentBlock := self Label.
		jump3 jmpTarget: currentBlock.
		s98 := s3 << 3.
		self AddCq: s98 R: t0.
		self MoveR: t1 M64: 8 r: t0.
		jump3 := self Jump: 0.
		currentBlock := self Label.
		jump8 jmpTarget: currentBlock.
		s102 := s3 << 3.
		self AddCq: s102 R: t0.
		self MoveR: t1 M64: 8 r: t0.
		currentBlock := self Label.
		jump7 jmpTarget: currentBlock.
		jump6 jmpTarget: currentBlock.
		jump1 jmpTarget: currentBlock.
		jump5 jmpTarget: currentBlock.
		jump2 jmpTarget: currentBlock.
		jump3 jmpTarget: currentBlock.
		^ 0 ].
	(self ssValue: 0) copyToReg: t1.
	self MoveR: t0 R: t2.
	self AndCq: 7 R: t2.
	self ssFlushStack.
	self CmpCq: 0 R: t2.
	jump3 := self JumpNonZero: 0.
	s38 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t0 R: t2.
	self AndCq: s38 R: t2.
	s41 := objectMemory getMemoryMap getOldSpaceMask.
	self CmpCq: s41 R: t2.
	jump2 := self JumpNonZero: 0.
	self MoveR: t1 R: t2.
	self AndCq: 7 R: t2.
	self CmpCq: 0 R: t2.
	jump5 := self JumpNonZero: 0.
	s46 := objectMemory getMemoryMap getSpaceMaskToUse.
	self MoveR: t1 R: t2.
	self AndCq: s46 R: t2.
	s49 := objectMemory getMemoryMap getNewSpaceMask.
	self CmpCq: s49 R: t2.
	jump1 := self JumpNonZero: 0.
	s51 := objectMemory getMemoryMap getNewSpaceStart.
	self MoveR: t1 R: t2.
	self CmpCq: s51 R: t2.
	jumpTrue := self JumpAboveOrEqual: 0.
	self MoveCq: 0 R: t2.
	jumpNext := self Jump: 0.
	jumpTrue jmpTarget: self Label.
	self MoveCq: 1 R: t2.
	jumpNext jmpTarget: self Label.
	self CmpCq: 1 R: t2.
	jump6 := self JumpNonZero: 0.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump7 := self JumpNonZero: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	jump8 := self Jump: 0.
	currentBlock := self Label.
	jump1 jmpTarget: currentBlock.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump7 jmpTarget: currentBlock.
	jump8 jmpTarget: currentBlock.
	self MoveM64: 0 r: t0 R: t2.
	self LogicalShiftRightCq: 29 R: t2.
	self AndCq: 1 R: t2.
	self CmpCq: 0 R: t2.
	jump8 := self JumpZero: 0.
	s68 := s3 << 3.
	self AddCq: s68 R: t0.
	self MoveR: t1 M64: 8 r: t0.
	jump7 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self TstCq: 7 R: t1.
	jump8 := self JumpZero: 0.
	s73 := s3 << 3.
	self AddCq: s73 R: t0.
	self MoveR: t1 M64: 8 r: t0.
	jump6 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	self CmpCq: 16r20000000000 R: t0.
	jump8 := self JumpLess: 0.
	self CmpCq: 16r20000000000 R: t1.
	jump5 := self JumpLess: 0.
	s79 := s3 << 3.
	self AddCq: s79 R: t0.
	self MoveR: t1 M64: 8 r: t0.
	jump2 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	self genMoveConstant: objectMemory nilObject R: t2.
	self CmpR: t2 R: t1.
	jump5 := self JumpBelow: 0.
	s85 := objectMemory trueObject.
	self CmpCq: s85 R: t1.
	jump3 := self JumpAbove: 0.
	s87 := s3 << 3.
	self AddCq: s87 R: t0.
	self MoveR: t1 M64: 8 r: t0.
	jump1 := self Jump: 0.
	currentBlock := self Label.
	jump5 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	s91 := objectMemory getMemoryMap getNewSpaceStart.
	self CmpCq: s91 R: t1.
	jump3 := self JumpBelow: 0.
	self MoveR: t0 R: TempReg.
	backEnd saveAndRestoreLinkRegAround: [
		self CallRT: ceStoreCheckTrampoline ].
	s94 := s3 << 3.
	self AddCq: s94 R: t0.
	self MoveR: t1 M64: 8 r: t0.
	jump5 := self Jump: 0.
	currentBlock := self Label.
	jump3 jmpTarget: currentBlock.
	s98 := s3 << 3.
	self AddCq: s98 R: t0.
	self MoveR: t1 M64: 8 r: t0.
	jump3 := self Jump: 0.
	currentBlock := self Label.
	jump8 jmpTarget: currentBlock.
	s102 := s3 << 3.
	self AddCq: s102 R: t0.
	self MoveR: t1 M64: 8 r: t0.
	currentBlock := self Label.
	jump7 jmpTarget: currentBlock.
	jump6 jmpTarget: currentBlock.
	jump2 jmpTarget: currentBlock.
	jump1 jmpTarget: currentBlock.
	jump5 jmpTarget: currentBlock.
	jump3 jmpTarget: currentBlock.
	^ 0
]
